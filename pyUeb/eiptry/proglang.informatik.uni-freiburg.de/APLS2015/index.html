<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Workshop: Advances in Programming Languages and Systems 2015</title>
<meta http-equiv="Content-Language" content="English" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" type="text/css" href="style.css" media="screen" />
</head>
<body>

<div id="wrap">
<a id="top" name ="top"/>
<div id="header">
<h1><a href="index.html#">Workshop: Advances in Programming Languages and Systems</a></h1>
<h2>Frankfurt a. M., December 15th -- December 16th 2015</h2>
</div>



<div id="content">
<div class="left"> 
  
  
  

<h2><a id="scope" name="scope">Scope</a></h2>
<div class="articles">
<p>Advances in programming language research increasingly influence the world of software development and big software companies recognize the importance of research areas like functional programming, static program analysis, run-time verification, automated software engineering and debugging as well as automated verification techniques.</p>
<p>This workshop is an opportunity to interact with leading international researchers in these areas, to receive crucial impulses, and to cultivate and maintain new and old collaborations and liaisons.</p>
<p>The talks will be given by prominent members of the programming languages research community and cover a wide area of topics inside this field. The list of talks can be found <a href="index.html#program">below</a>.</p>
<p>The workshop is sponsored by the DFG.</p>
</div>


<br /><br />
<img src="images/frankfurt.jpg" alt="Frankfurt" style="border: 3px solid #ccc;" />
<br/>


<h2><a id="logistics" name="logistics">Logistics</a></h2>
<div class="articles">
<p>The workshop will take place at <strong>Campus Westend, University of Frankfurt</strong>, in the <strong>Casino-Gebäude</strong>. The building is right behind the “IG Farben Haus”.</p>
<iframe src="https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d2557.832507651278!2d8.664841766001155!3d50.126856079432!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x47bd094a16409f83%3A0xe8819c585a4c1f31!2sGoethe+Universit%C3%A4t+-+Casino-Geb%C3%A4ude%2C+60323+Frankfurt+am+Main!5e0!3m2!1sen!2sde!4v1444392623052" width="600" height="450" frameborder="0" style="border:0" allowfullscreen>
</iframe>
<h3 id="directions-to-campus-westend">Directions to Campus Westend</h3>
<p>Frankfurt am Main is excellently connected. If you arrive by plane, take a train to the Frankfurt Main Station (Hauptbahnhof).</p>
<ul>
<li>From the <strong>main station</strong>:
<ul>
<li>Take the S-Bahn 1/2/3/4/5/6/8/9 to <strong>Hauptwache</strong>, then U-Bahn 1/2/3/8 to <strong>Holzhausenstraße</strong>. Continue to Campus Westend by foot (approx. 10 min).</li>
<li>Or, take S-Bahn 1/2/3/4/5/6/8 to <strong>Konstabler Wache</strong>, then Bus 36 (direction Westbahnhof) to <strong>Uni Campus Westend</strong></li>
<li>Or, take Bus 64 to <strong>Bremer Straße</strong></li>
</ul></li>
<li>From <strong>Westbahnhof</strong>: take bus 36 (direction “Hainer Weg”) to <strong>Uni Campus Westend</strong></li>
</ul>
</div>


<h2><a id="accomodation" name="accomodation">Accomodation</a></h2>
<div class="articles">
<p>We recommend to check <a href="https://www.google.com/maps/search/hotels/@50.1236001,8.6670122,14z/data=!3m1!4b1!4m8!2m7!3m6!1shotels!2sIG+Farben+Haus,+Norbert-Wollheim-Platz+1,+60323+Frankfurt+am+Main!3s0x47bd094bb376047d:0x2d555d81da79411!4m2!1d8.6674505!2d50.1254445?hl=en-US">Google Maps for a hotel nearby <strong>Campus Westend</strong></a> There is a greater choice of reasonably priced hotels close to the main station.</p>
</div>


<h2><a id="program" name="program">Program</a></h2>
<div class="articles">
<p>The <strong>registration desk</strong> will open <strong>Tuesday</strong> at <strong>12:30</strong>. The rough time-table for the workshop is as follows. A detailed schedule can be found <a href="talks-schedule.html">here</a>.</p>
<div class="schedule-table">
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">Morning Sessions</th>
<th align="left">Afternoon Sessions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Tuesday</td>
<td align="left"></td>
<td align="left">14:00 – 17:20</td>
</tr>
<tr class="even">
<td align="left">Wednesday</td>
<td align="left">9:00 – 12:20</td>
<td align="left">14:00 – 16:45</td>
</tr>
</tbody>
</table>
</div>
<h3 id="list-of-talks">List of talks</h3>
<table>
<tr>
<td>
<p>Andreas Abel<br/><b>Coinductive programming with copatterns</b></p>
(<a href="slides/Andreas&#32;Abel&#32;-&#32;Coinductive&#32;programming&#32;with&#32;copatterns.zip">slides</a>)
</td>
</tr>
<tr>
<td>
Arthur Charguéraud<br/><b>Machine-checked verification of amortized complexity analyses</b> (<input id="Machine-checked verification of amortized complexity analyses-abstract-toggle" class="uncover-abstract" type="checkbox"/><label for="Machine-checked verification of amortized complexity analyses-abstract-toggle">
<div id="Machine-checked verification of amortized complexity analyses-abstract-show">
show
</div>
<div id="Machine-checked verification of amortized complexity analyses-abstract-hide">
hide
</div>
abstract</label> )
<div id="Machine-checked verification of amortized complexity analyses-abstract">
<p>In this talk, I will argue that formally verifying the correctness and the termination of a program is not sufficient: to prevent bugs, one ought to also verify the asymptotic complexity of the program. I will present an extension of CFML, a Coq-based verification tool for imperative programs, with time credits, which allow establishing the amortized asymptotic complexity of a program in Separation Logic. I will present application of this tool to the verification of the correctness and asymptotic complexity of an OCaml implementation of the classic Union-Find data structure, which yields a bound expressed using the inverse Ackermann function.</p>
</div>
(<a href="slides/Arthur&#32;Chargueraud&#32;-&#32;Machine-checked&#32;verification&#32;of&#32;amortized&#32;complexity&#32;analyses.pdf">slides</a>)
</td>
</tr>
<tr>
<td>
Dominique Devriese<br/><b>Reasoning about Object Capabilities with Logical Relations and Effect Parametricity</b> (<input id="Reasoning about Object Capabilities with Logical Relations and Effect Parametricity-abstract-toggle" class="uncover-abstract" type="checkbox"/><label for="Reasoning about Object Capabilities with Logical Relations and Effect Parametricity-abstract-toggle">
<div id="Reasoning about Object Capabilities with Logical Relations and Effect Parametricity-abstract-show">
show
</div>
<div id="Reasoning about Object Capabilities with Logical Relations and Effect Parametricity-abstract-hide">
hide
</div>
abstract</label> )
<div id="Reasoning about Object Capabilities with Logical Relations and Effect Parametricity-abstract">
<p>Object capabilities are a technique for fine-grained privilege separation in programming languages and systems, with important applications in security. However, current formal characterisations do not fully capture capability-safety of a programming language and are not sufficient for verifying typical applications. Using state-of-the-art techniques from programming languages research, we define a logical relation for a core calculus of JavaScript that better characterises capability-safety. The relation is powerful enough to reason about typical capability patterns and supports evolvable invariants on shared data structures, capabilities with restricted authority over them and isolated components with restricted communication channels. We use a novel notion of effect parametricity for deriving properties about effects. We demonstrate that our results imply memory access bounds that have previously been used to characterise capability-safety.</p>
</div>
(<a href="slides/Dominique&#32;Devriese&#32;-&#32;Reasoning&#32;about&#32;Object&#32;Capabilities&#32;with&#32;Logical&#32;Relations&#32;and&#32;Effect&#32;Parametricity.pdf">slides</a>)
</td>
</tr>
<tr>
<td>
<p>Sophia Drossopoulou<br/><b>Reasoning about Programs in the Presence of Code of Unknown Provenance</b></p>
(<a href="slides/Sophia&#32;Drossopoulou&#32;-&#32;Reasoning&#32;about&#32;Programs&#32;in&#32;the&#32;Presence&#32;of&#32;Code&#32;of&#32;Unknown&#32;Provenance.pdf">slides</a>)
</td>
</tr>
<tr>
<td>
<p>Joshua Dunfield<br/><b>Evaluation-order Polymorphism</b></p>
</td>
</tr>
<tr>
<td>
Luminous Fennell<br/><b>Gradual Security Typing</b> (<input id="Gradual Security Typing-abstract-toggle" class="uncover-abstract" type="checkbox"/><label for="Gradual Security Typing-abstract-toggle">
<div id="Gradual Security Typing-abstract-show">
show
</div>
<div id="Gradual Security Typing-abstract-hide">
hide
</div>
abstract</label> )
<div id="Gradual Security Typing-abstract">
<p>Static type checking guarantees the absence of particular classes of errors at run-time but may also impede programmer productivity by rejecting programs that are dynamically safe. Dynamic typing allows a flexible programming style but unsafe programs crash at run-time. Gradual typing combines static and dynamic typing into a single language to allow programmers to use both typing disciplines in their projects as appropriate. Gradual Security Typing applies the principles of gradual typing to type systems for information flow control. We start with a Java core calculus and a standard security type system that annotates types with security levels. To “gradualize” the calculus we extend it with a dynamic security annotation that is ignored during typechecking, and cast instructions that convert between dynamically and statically annotated types. The information flow for values of dynamic type is checked at run-time using standard dynamic or hybrid information flow control. Passing values between dynamically and statically typed code is only possible through casts which ensures that static code does not require dynamic checking.</p>
</div>
(<a href="slides/Luminous&#32;Fennell&#32;-&#32;Gradual&#32;Security&#32;Typing.pdf">slides</a>)
</td>
</tr>
<tr>
<td>
Matthew Fluet<br/><b>Type- and Control-Flow Analysis</b> (<input id="Type- and Control-Flow Analysis-abstract-toggle" class="uncover-abstract" type="checkbox"/><label for="Type- and Control-Flow Analysis-abstract-toggle">
<div id="Type- and Control-Flow Analysis-abstract-show">
show
</div>
<div id="Type- and Control-Flow Analysis-abstract-hide">
hide
</div>
abstract</label> )
<div id="Type- and Control-Flow Analysis-abstract">
<p>We present some recent and future work on improving the precision of control-flow analyses for languages with rich static type systems. In particular, we give a monovariant flow analysis for System~F (with recursion) that yields both <em>control-flow</em> information, approximating the <span class="math inline"><em>λ</em></span>- and <span class="math inline"><em>Λ</em></span>-expressions that may be bound to variables, and <em>type-flow</em> information, approximating the type expressions that may instantiate type variables. Moreover, the two flows are mutually beneficial: the control flow determines which <span class="math inline"><em>Λ</em></span>-expressions may be applied to which type expressions (and, hence, which type expressions may instantiate which type variables), while the type flow filters the <span class="math inline"><em>λ</em></span>- and <span class="math inline"><em>Λ</em></span>-expressions that may be bound to variables (by rejecting expressions with static types that are incompatible with the static type of the variable under the type flow). We briefly recount the key challenges in obtaining a decidable analysis and an efficient algorithm and consider future directions for this research.</p>
</div>
(<a href="slides/Matthew&#32;Fluet&#32;-&#32;Type-&#32;and&#32;Control-Flow&#32;Analysis.pdf">slides</a>)
</td>
</tr>
<tr>
<td>
<p>Christian Hammer<br/><b>Declassification in the Browser</b></p>
</td>
</tr>
<tr>
<td>
Atsushi Igarashi<br/><b>A Sound Type System for Layer Subtyping and Dynamically Activated First-Class Layers</b> (<input id="A Sound Type System for Layer Subtyping and Dynamically Activated First-Class Layers-abstract-toggle" class="uncover-abstract" type="checkbox"/><label for="A Sound Type System for Layer Subtyping and Dynamically Activated First-Class Layers-abstract-toggle">
<div id="A Sound Type System for Layer Subtyping and Dynamically Activated First-Class Layers-abstract-show">
show
</div>
<div id="A Sound Type System for Layer Subtyping and Dynamically Activated First-Class Layers-abstract-hide">
hide
</div>
abstract</label> )
<div id="A Sound Type System for Layer Subtyping and Dynamically Activated First-Class Layers-abstract">
<p>Key features of context-oriented programming (COP) are LAYERS—modules to describe context-dependent behavioral variations of a software system—and their DYNAMIC ACTIVATION, which can modify the behavior of multiple objects that have already been instantiated. Typechecking programs written in a COP language is difficult because the activation of a layer can even change objects’ interfaces. We formalize a small COP language called ContextFJ&lt;: with its operational semantics and type system and show its soundness. The language features (1) dynamically activated FIRST-CLASS layers, (2) INHERITANCE of layer definitions, and (3) layer SUBTYPING.</p>
</div>
(<a href="slides/Atsushi&#32;Igarashi&#32;-&#32;A&#32;Sound&#32;Type&#32;System&#32;for&#32;Layer&#32;Subtyping&#32;and&#32;Dynamically&#32;Activated&#32;First-Class&#32;Layers.pdf">slides</a>)
</td>
</tr>
<tr>
<td>
<p>Ranjit Jhala<br/><b>Bounded Refinement Types</b></p>
</td>
</tr>
<tr>
<td>
Ivan Lanese<br/><b>Reversible Concurrent Systems</b> (<input id="Reversible Concurrent Systems-abstract-toggle" class="uncover-abstract" type="checkbox"/><label for="Reversible Concurrent Systems-abstract-toggle">
<div id="Reversible Concurrent Systems-abstract-show">
show
</div>
<div id="Reversible Concurrent Systems-abstract-hide">
hide
</div>
abstract</label> )
<div id="Reversible Concurrent Systems-abstract">
<p>Reversibility allows the execution of programs not only in the standard, forward direction, but also backward, going to past states. The notion of reversibility suited to concurrent systems is causal-consistent reversibility, where any action can be undone provided that its consequences (if any) are undone beforehand. We will discuss the basic theory of causal-consistent reversibility, together with applications to reliability and to debugging.</p>
</div>
(<a href="slides/Ivan&#32;Lanese&#32;-&#32;Reversible&#32;Concurrent&#32;Systems.pdf">slides</a>)
</td>
</tr>
<tr>
<td>
Anders Møller<br/><b>Message Safety in Dart</b> (<input id="Message Safety in Dart-abstract-toggle" class="uncover-abstract" type="checkbox"/><label for="Message Safety in Dart-abstract-toggle">
<div id="Message Safety in Dart-abstract-show">
show
</div>
<div id="Message Safety in Dart-abstract-hide">
hide
</div>
abstract</label> )
<div id="Message Safety in Dart-abstract">
<p>Unlike traditional static type checking, the type system in the Dart programming language is unsound by design, even for fully annotated programs. The rationale has been that this allows compile-time detection of likely errors and enables code completion in integrated development environments, without being restrictive on programmers.</p>
<p>Despite unsoundness, judicious use of type annotations can ensure useful properties of the runtime behavior of Dart programs. We present a formal model of a core of Dart with a focus on its type system, which allows us to elucidate the causes of unsoundness. Our main contribution is a characterization of message-safe programs and a theorem stating that such programs will never encounter ‘message not understood’ errors at runtime. Message safety is less restrictive than traditional type soundness, and we argue that it forms a natural intermediate point between dynamically typed and statically typed Dart programs.</p>
</div>
</td>
</tr>
<tr>
<td>
<p>Keiko Nakata<br/><b>Formal Verification of a Microkernel at FireEye</b></p>
</td>
</tr>
<tr>
<td>
James Noble<br/><b>On Grace</b> (<input id="On Grace-abstract-toggle" class="uncover-abstract" type="checkbox"/><label for="On Grace-abstract-toggle">
<div id="On Grace-abstract-show">
show
</div>
<div id="On Grace-abstract-hide">
hide
</div>
abstract</label> )
<div id="On Grace-abstract">
<p>Grace is new purely object-oriented educational language that we are developing. Grace needs some kind of support for “code reuse” but what should we choose: inheritance, delegation, or something else? Inheritance and delegation are often considered roughly equivalent, but differ strongly in the details. Grace’s hopes to support both object- and class-based programming is greatly complicated by this difference.</p>
</div>
(<a href="slides/James&#32;Noble&#32;-&#32;On&#32;Grace.pdf">slides</a>)
</td>
</tr>
<tr>
<td>
<p>Klaus Ostermann<br/><b>Automatic Refunctionalization</b></p>
</td>
</tr>
<tr>
<td>
Matthew Parkinson<br/><b>The Push/Pull Model of Transactions</b> (<input id="The Push/Pull Model of Transactions-abstract-toggle" class="uncover-abstract" type="checkbox"/><label for="The Push/Pull Model of Transactions-abstract-toggle">
<div id="The Push/Pull Model of Transactions-abstract-show">
show
</div>
<div id="The Push/Pull Model of Transactions-abstract-hide">
hide
</div>
abstract</label> )
<div id="The Push/Pull Model of Transactions-abstract">
<p>We present a general theory of serializability, unifying a wide range of transactional algorithms, including some that are yet to come. To this end, we provide a compact semantics in which concurrent transactions PUSH their effects into the shared view (or UNPUSH to recall effects) and PULL the effects of potentially uncommitted concurrent transactions into their local view (or UNPULL to detangle). Each operation comes with simple criteria given in terms of commutativity (Lipton’s left-movers and right-movers). The beneﬁt of this model is that most of the elaborate reasoning (coinduction, simulation, subtle invariants, etc.) necessary for proving the serializability of a transactional algorithm is already proved within the semantic model. Thus, proving serializability (or opacity) amounts simply to mapping the algorithm on to our rules, and showing that it satisﬁes the rules’ criteria.</p>
</div>
</td>
</tr>
<tr>
<td>
Didier Rémy<br/><b>Full Reduction and GADTs</b> (<input id="Full Reduction and GADTs-abstract-toggle" class="uncover-abstract" type="checkbox"/><label for="Full Reduction and GADTs-abstract-toggle">
<div id="Full Reduction and GADTs-abstract-show">
show
</div>
<div id="Full Reduction and GADTs-abstract-hide">
hide
</div>
abstract</label> )
<div id="Full Reduction and GADTs-abstract">
<p>Although type soundness is usually proved for a call-by-value semantics, it often also holds for full reduction, as is the case in core ML, System F, or Fsub. Hence, these type systems prevent erroneous expressions to appear in any context—a useful property that the programmer knows.</p>
<p>However, this is no more true with GADTs (or dependent types): full reduction could be unsafe in branches of GADTs that make type assumptions that may not hold in all executions of the program. The usual solution to freeze the evaluation in all branches of GADTs is too coarse.</p>
<p>We argue that when extending a language with propositions, we should distinguish consistent assumptions, which are erasable from possibly inconsistent assumptions, which are not and must delay the evaluation. We also introduce hiding of assumptions, to allow full reduction of subexpressions that do not depend on inconsistent assumptions. This increases flexibility, but it is also necessary to recover confluence.</p>
</div>
(<a href="slides/Didier&#32;Remy&#32;-&#32;Full&#32;Reduction&#32;and&#32;GADTs.pdf">slides</a>)
</td>
</tr>
<tr>
<td>
Francesco Ranzato<br/><b>Analysing Completeness in Program Analysis</b> (<input id="Analysing Completeness in Program Analysis-abstract-toggle" class="uncover-abstract" type="checkbox"/><label for="Analysing Completeness in Program Analysis-abstract-toggle">
<div id="Analysing Completeness in Program Analysis-abstract-show">
show
</div>
<div id="Analysing Completeness in Program Analysis-abstract-hide">
hide
</div>
abstract</label> )
<div id="Analysing Completeness in Program Analysis-abstract">
<p>We want to prove that a static analysis of a given program is complete, namely, no imprecision arises when asking some query on the program behavior in the concrete (i.e. for its concrete semantics) or in the abstract (i.e. for its abstract interpretation). Completeness proofs are therefore useful to assign confidence to alarms raised by static analyses. We introduce the completeness class of an abstraction as the set of all programs for which the abstraction is complete. We show that for any nontrivial abstraction, its completeness class is not recursively enumerable. We then introduce a stratified deductive system to prove the completeness of program analyses over an abstract domain A. We prove the soundness of the deductive system and we observe that the only sources of incompleteness are assignments and Boolean tests — unlikely a common belief in static analysis, joins do not induce incompleteness. The first layer of this proof system is generic, abstraction-agnostic, and it deals with the standard constructs for program composition, that is, sequential composition, branching and guarded iteration. The second layer is instead abstraction-specific: the designer of an abstract domain A provides conditions for completeness in A of assignments and Boolean tests which have to be checked by a suitable static analysis or assumed in the completeness proof as hypotheses. We instantiate the second layer of this proof system first with a generic nonrelational abstraction in order to provide a sound rule for the completeness of assignments. Orthogonally, we instantiate it to the numerical abstract domains of Intervals and Octagons, providing necessary and sufficient conditions for the completeness of their Boolean tests and of assignments for Octagons.</p>
</div>
(<a href="slides/Francesco&#32;Ranzato&#32;-&#32;Analysing&#32;Completeness&#32;in&#32;Program&#32;Analysis.pdf">slides</a>)
</td>
</tr>
<tr>
<td>
Ilya Sergey<br/><b>Hoare-style Specifications as Correctness Conditions for Non-linearizable Concurrent Objects</b> (<input id="Hoare-style Specifications as Correctness Conditions for Non-linearizable Concurrent Objects-abstract-toggle" class="uncover-abstract" type="checkbox"/><label for="Hoare-style Specifications as Correctness Conditions for Non-linearizable Concurrent Objects-abstract-toggle">
<div id="Hoare-style Specifications as Correctness Conditions for Non-linearizable Concurrent Objects-abstract-show">
show
</div>
<div id="Hoare-style Specifications as Correctness Conditions for Non-linearizable Concurrent Objects-abstract-hide">
hide
</div>
abstract</label> )
<div id="Hoare-style Specifications as Correctness Conditions for Non-linearizable Concurrent Objects-abstract">
<p>Designing scalable concurrent objects, which can be efficiently used on multicore processors, often requires one to abandon standard specification techniques, such as linearizability, in favor of more relaxed consistency requirements. However, the variety of alternative correctness conditions makes it difficult to choose which one to employ in a particular case, and to compose them when using objects whose behaviors are specified via different criteria. The lack of syntactic verification methods for most of these criteria poses challenges in their systematic adoption and application.</p>
<p>In this work, we argue for using Hoare-style program logics as an alternative and uniform approach for specification and compositional formal verification of safety properties for concurrent objects and heir client programs. Through a series of case studies, we demonstrate how an existing program logic for concurrency can be employed off-the-shelf to capture important state and history invariants, allowing one to explicitly quantify over interference of environment threads and provide intuitive and expressive Hoare-style specifications for several non-linearizable concurrent objects that were previously specified only via dedicated correctness criteria. We illustrate the adequacy of our specifications by verifying a number of concurrent client scenarios, that make use of the previously specified concurrent objects, capturing the essence of such correctness conditions as concurrency-aware linearizability, quiescent, and quantitative quiescent consistency.</p>
</div>
(<a href="slides/Ilya&#32;Sergey&#32;-&#32;Hoare-style&#32;Specifications&#32;as&#32;Correctness&#32;Conditions&#32;for&#32;Non-linearizable&#32;Concurrent&#32;Objects.pdf">slides</a>)
</td>
</tr>
<tr>
<td>
<p>Jeremy Siek<br/><b>A Tracing JIT for a Functional Language</b></p>
(<a href="slides/Jeremy&#32;Siek&#32;-&#32;A&#32;Tracing&#32;JIT&#32;for&#32;a&#32;Functional&#32;Language.pdf">slides</a>)
</td>
</tr>
<tr>
<td>
Wouter Swierstra<br/><b>Auto in Agda</b> (<input id="Auto in Agda-abstract-toggle" class="uncover-abstract" type="checkbox"/><label for="Auto in Agda-abstract-toggle">
<div id="Auto in Agda-abstract-show">
show
</div>
<div id="Auto in Agda-abstract-hide">
hide
</div>
abstract</label> )
<div id="Auto in Agda-abstract">
<p>As proofs in type theory become increasingly complex, there is a growing need to provide better proof automation. This paper shows how to implement a Prolog-style resolution procedure in the dependently typed programming language Agda. Connecting this resolution procedure to Agda’s reflection mechanism provides a first-class proof search tactic for first-order Agda terms. As a result, writing proof automation tactics need not be different from writing any other program.</p>
</div>
(<a href="slides/Wouter&#32;Swierstra&#32;-&#32;Auto&#32;in&#32;Agda.pdf">slides</a>)
</td>
</tr>
<tr>
<td>
<p>Peter Thiemann<br/><b>Derivatives in Program Analysis</b></p>
(<a href="slides/Peter&#32;Thiemann&#32;-&#32;Derivatives&#32;in&#32;Program&#32;Analysis.pdf">slides</a>)
</td>
</tr>
<tr>
<td>
Vasco Vasconcelos<br/><b>Protocol-based Verification of Message-passing Parallel Programs</b> (<input id="Protocol-based Verification of Message-passing Parallel Programs-abstract-toggle" class="uncover-abstract" type="checkbox"/><label for="Protocol-based Verification of Message-passing Parallel Programs-abstract-toggle">
<div id="Protocol-based Verification of Message-passing Parallel Programs-abstract-show">
show
</div>
<div id="Protocol-based Verification of Message-passing Parallel Programs-abstract-hide">
hide
</div>
abstract</label> )
<div id="Protocol-based Verification of Message-passing Parallel Programs-abstract">
<p>We present ParTypes, a type-based methodology for the verification of Message Passing Interface (MPI) programs written in the C programming language. The aim is to statically verify programs against protocol specifications, enforcing properties such as fidelity and absence of deadlocks. We develop a protocol language based on a dependent type system for message-passing parallel programs, which includes various communication operators, such as point-to-point messages, broadcast, reduce, array scatter and gather. For the verification of a program against a given protocol, the protocol is first translated into a representation read by VCC, a software verifier for C. We successfully verified several MPI programs in a running time that is independent of the number of processes or other input parameters. This contrasts with alternative techniques, notably model checking and runtime verification, that suffer from the state-explosion problem or that otherwise depend on parameters to the program itself. We experimentally evaluated our approach against state-of-the-art tools for MPI to conclude that our approach offers a scalable solution [joint with Hugo López, Eduardo Marques, Francisco Martins, Nicholas Ng, César Santos, Nobuko Yoshida]</p>
</div>
(<a href="slides/Vasco&#32;Vasconcelos&#32;-&#32;Protocol-based&#32;Verification&#32;of&#32;Message-passing&#32;Parallel&#32;Programs.pdf">slides</a>)
</td>
</tr>
</table>
</div>


<h2><a id="registration" name="registration">Registration</a></h2>
<div class="articles">
<p><strong>Deadline for registration is Thursday, December 10th, 2015</strong>.</p>
<p>The workshop fee is <strong>50 €</strong>, to be paid in cash at the registration desk. The fee includes coffee breaks but no meals. The number of participants is limited and registrations will be processed in a first-come-first-served manner.</p>
<iframe src="https://docs.google.com/forms/d/1ajJiZUvqWPfPJ5gU_bd8QFR6plW1IyoOUoC2BiBcllw/viewform?embedded=true" width="760" height="500" frameborder="0" marginheight="0" marginwidth="0">
Loading…
</iframe>
</div>


<h2><a id="organization" name="organization">Organization</a></h2>
<div class="articles">
<ul>
<li><a href="http://creichen.net/">Prof. Dr. Christoph Reichenbach</a> Goethe University Frankfurt</li>
<li><a href="http://www.informatik.uni-freiburg.de/~thiemann">Prof. Dr. Peter Thiemann</a> University of Freiburg</li>
<li><a href="http://www.informatik.uni-freiburg.de/~fennell">Luminous Fennell</a> University of Freiburg</li>
</ul>
<p>Please contact <strong>Luminous Fennell</strong> (<script type="text/javascript">
<!--
h='&#x69;&#110;&#102;&#x6f;&#114;&#x6d;&#x61;&#116;&#x69;&#x6b;&#46;&#x75;&#110;&#x69;&#x2d;&#102;&#114;&#x65;&#x69;&#98;&#x75;&#114;&#x67;&#46;&#100;&#x65;';a='&#64;';n='&#102;&#x65;&#110;&#110;&#x65;&#108;&#108;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#102;&#x65;&#110;&#110;&#x65;&#108;&#108;&#32;&#x61;&#116;&#32;&#x69;&#110;&#102;&#x6f;&#114;&#x6d;&#x61;&#116;&#x69;&#x6b;&#32;&#100;&#x6f;&#116;&#32;&#x75;&#110;&#x69;&#x2d;&#102;&#114;&#x65;&#x69;&#98;&#x75;&#114;&#x67;&#32;&#100;&#x6f;&#116;&#32;&#100;&#x65;</noscript>) with any further questions regarding the workshop.</p>
</div>


</div>

<div class="right"> 

<ul>
<li><a href="index.html#logistics">Logistics</a>
</li> 
<li><a href="index.html#accomodation">Accomodation</a>
</li> 
<li><a href="index.html#program">Program</a>
</li> 
<li><a href="index.html#registration">Registration</a>
</li>
<li><a href="index.html#organization">Organization</a>
</li>
</ul>

</div>
<div style="clear: both;"> </div>
</div>

<div id="footer">
Designed by <a href="http://www.free-css-templates.com/">Free CSS Templates</a>, Thanks to <a href="http://www.openwebdesign.org/">website design</a>
</div>
</div>

</body>
</html>
