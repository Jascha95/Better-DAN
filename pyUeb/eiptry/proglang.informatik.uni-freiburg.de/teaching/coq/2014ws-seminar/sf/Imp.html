<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Imp</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Imp</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab390"></a><h1 class="section">Imp: Simple Imperative Programs</h1>

<div class="paragraph"> </div>

 In this chapter, we begin a new direction that will continue for
    the rest of the course.  Up to now most of our attention has been
    focused on various aspects of Coq itself, while from now on we'll
    mostly be using Coq to formalize other things.  (We'll continue to
    pause from time to time to introduce a few additional aspects of
    Coq.)

<div class="paragraph"> </div>

    Our first case study is a <i>simple imperative programming language</i>
    called Imp, embodying a tiny core fragment of conventional
    mainstream languages such as C and Java.  Here is a familiar
    mathematical function written in Imp.
     Z ::= X;;
     Y ::= 1;;
     WHILE not (Z = 0) DO
       Y ::= Y * Z;;
       Z ::= Z - 1
     END

<div class="paragraph"> </div>

 This chapter looks at how to define the <i>syntax</i> and <i>semantics</i>
    of Imp; the chapters that follow develop a theory of <i>program
    equivalence</i> and introduce <i>Hoare Logic</i>, a widely used logic for
    reasoning about imperative programs. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab391"></a><h3 class="section">Sflib</h3>
 <a name="sflib"/> *)

(** A minor technical point: Instead of asking Coq to import our
    earlier definitions from chapter [Logic], we import a small library
    called [Sflib.v], containing just a few definitions and theorems
    from earlier chapters that we'll actually use in the rest of the
    course.  This change should be nearly invisible, since most of what's
    missing from Sflib has identical definitions in the Coq standard
    library.  The main reason for doing it is to tidy the global Coq
    environment so that, for example, it is easier to search for
    relevant theorems. *)

Require Export SfLib.

(* ########################### <a name="lab392"></a><h1 class="section">Arithmetic and Boolean Expressions</h1>

<div class="paragraph"> </div>

 We'll present Imp in three parts: first a core language of
    <i>arithmetic and boolean expressions</i>, then an extension of these
    expressions with <i>variables</i>, and finally a language of <i>commands</i>
    including assignment, conditions, sequencing, and loops. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab393"></a><h2 class="section">Syntax</h2>
 <a name="exp-syntax"/> *)

Module AExp.

(** These two definitions specify the _abstract syntax_ of
    arithmetic and boolean expressions. *)

Inductive aexp : Type :=
  | ANum : nat -> aexp
  | APlus : aexp -> aexp -> aexp
  | AMinus : aexp -> aexp -> aexp
  | AMult : aexp -> aexp -> aexp.

Inductive bexp : Type :=
  | BTrue : bexp
  | BFalse : bexp
  | BEq : aexp -> aexp -> bexp
  | BLe : aexp -> aexp -> bexp
  | BNot : bexp -> bexp
  | BAnd : bexp -> bexp -> bexp.

(** In this chapter, we'll elide the translation from the
    concrete syntax that a programmer would actually write to these
    abstract syntax trees -- the process that, for example, would
    translate the string ["1+2*3"] to the AST [APlus (ANum
    1) (AMult (ANum 2) (ANum 3))].  The optional chapter [ImpParser]
    develops a simple implementation of a lexical analyzer and parser
    that can perform this translation.  You do _not_ need to
    understand that file to understand this one, but if you haven't
    taken a course where these techniques are covered (e.g., a
    compilers course) you may want to skim it. *)

(** *** *)
(** For comparison, here's a conventional BNF (Backus-Naur Form)
    grammar defining the same abstract syntax:
    a ::= nat
        | a + a
        | a - a
        | a * a

    b ::= true
        | false
        | a = a
        | a <= a
        | not b
        | b and b
*)

(** Compared to the Coq version above...

       - The BNF is more informal -- for example, it gives some
         suggestions about the surface syntax of expressions (like the
         fact that the addition operation is written [+] and is an
         infix symbol) while leaving other aspects of lexical analysis
         and parsing (like the relative precedence of [+], [-], and
         [*]) unspecified.  Some additional information -- and human
         intelligence -- would be required to turn this description
         into a formal definition (when implementing a compiler, for
         example).

         The Coq version consistently omits all this information and
         concentrates on the abstract syntax only.

       - On the other hand, the BNF version is lighter and
         easier to read.  Its informality makes it flexible, which is
         a huge advantage in situations like discussions at the
         blackboard, where conveying general ideas is more important
         than getting every detail nailed down precisely.

         Indeed, there are dozens of BNF-like notations and people
         switch freely among them, usually without bothering to say which
         form of BNF they're using because there is no need to: a
         rough-and-ready informal understanding is all that's
         needed. *)

(** It's good to be comfortable with both sorts of notations:
    informal ones for communicating between humans and formal ones for
    carrying out implementations and proofs. *)

(* ########################### <a name="lab394"></a><h2 class="section">Evaluation</h2>
 <a name="exp-eval"/> *)

(** _Evaluating_ an arithmetic expression produces a number. *)

Fixpoint aeval (a : aexp) : nat :=
  match a with
  | ANum n => n
  | APlus a1 a2 => (aeval a1) + (aeval a2)
  | AMinus a1 a2  => (aeval a1) - (aeval a2)
  | AMult a1 a2 => (aeval a1) * (aeval a2)
  end.

Example test_aeval1:
  aeval (APlus (ANum 2) (ANum 2)) = 4.
Proof. reflexivity. Qed.

(** *** *)
(** Similarly, evaluating a boolean expression yields a boolean. *)

Fixpoint beval (b : bexp) : bool :=
  match b with
  | BTrue       => true
  | BFalse      => false
  | BEq a1 a2   => beq_nat (aeval a1) (aeval a2)
  | BLe a1 a2   => ble_nat (aeval a1) (aeval a2)
  | BNot b1     => negb (beval b1)
  | BAnd b1 b2  => andb (beval b1) (beval b2)
  end.

(* ########################### <a name="lab395"></a><h2 class="section">Optimization</h2>

<div class="paragraph"> </div>

 We haven't defined very much yet, but we can already get
    some mileage out of the definitions.  Suppose we define a function
    that takes an arithmetic expression and slightly simplifies it,
    changing every occurrence of <span class="inlinecode">0+<a class="idref" href="Poly.html#MumbleBaz.e"><span class="id" type="constructor">e</span></a></span> (i.e., <span class="inlinecode">(<a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a></span> <span class="inlinecode">(<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a></span> <span class="inlinecode">0)</span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.e"><span class="id" type="constructor">e</span></a></span>)
    into just <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.e"><span class="id" type="constructor">e</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="AExp.optimize_0plus"><span class="id" type="definition">optimize_0plus</span></a> (<span class="id" type="var">a</span>:<a class="idref" href="Imp.html#AExp.aexp"><span class="id" type="inductive">aexp</span></a>) : <a class="idref" href="Imp.html#AExp.aexp"><span class="id" type="inductive">aexp</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Imp.html#a"><span class="id" type="variable">a</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#AExp.ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#AExp.ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#AExp.APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AExp.ANum"><span class="id" type="constructor">ANum</span></a> 0) <span class="id" type="var">e2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#optimize_0plus"><span class="id" type="definition">optimize_0plus</span></a> <span class="id" type="var">e2</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#AExp.APlus"><span class="id" type="constructor">APlus</span></a> <span class="id" type="var">e1</span> <span class="id" type="var">e2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#AExp.APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#optimize_0plus"><span class="id" type="definition">optimize_0plus</span></a> <span class="id" type="var">e1</span>) (<a class="idref" href="Imp.html#optimize_0plus"><span class="id" type="definition">optimize_0plus</span></a> <span class="id" type="var">e2</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#AExp.AMinus"><span class="id" type="constructor">AMinus</span></a> <span class="id" type="var">e1</span> <span class="id" type="var">e2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#AExp.AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#optimize_0plus"><span class="id" type="definition">optimize_0plus</span></a> <span class="id" type="var">e1</span>) (<a class="idref" href="Imp.html#optimize_0plus"><span class="id" type="definition">optimize_0plus</span></a> <span class="id" type="var">e2</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#AExp.AMult"><span class="id" type="constructor">AMult</span></a> <span class="id" type="var">e1</span> <span class="id" type="var">e2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#AExp.AMult"><span class="id" type="constructor">AMult</span></a> (<a class="idref" href="Imp.html#optimize_0plus"><span class="id" type="definition">optimize_0plus</span></a> <span class="id" type="var">e1</span>) (<a class="idref" href="Imp.html#optimize_0plus"><span class="id" type="definition">optimize_0plus</span></a> <span class="id" type="var">e2</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
To make sure our optimization is doing the right thing we
    can test it on some examples and see if the output looks OK. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="AExp.test_optimize_0plus"><span class="id" type="definition">test_optimize_0plus</span></a>:<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#AExp.optimize_0plus"><span class="id" type="definition">optimize_0plus</span></a> (<a class="idref" href="Imp.html#AExp.APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AExp.ANum"><span class="id" type="constructor">ANum</span></a> 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#AExp.APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AExp.ANum"><span class="id" type="constructor">ANum</span></a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#AExp.APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AExp.ANum"><span class="id" type="constructor">ANum</span></a> 0) (<a class="idref" href="Imp.html#AExp.ANum"><span class="id" type="constructor">ANum</span></a> 1))))<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#AExp.APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AExp.ANum"><span class="id" type="constructor">ANum</span></a> 2) (<a class="idref" href="Imp.html#AExp.ANum"><span class="id" type="constructor">ANum</span></a> 1).<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
But if we want to be sure the optimization is correct --
    i.e., that evaluating an optimized expression gives the same
    result as the original -- we should prove it. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="AExp.optimize_0plus_sound"><span class="id" type="lemma">optimize_0plus_sound</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#AExp.aeval"><span class="id" type="definition">aeval</span></a> (<a class="idref" href="Imp.html#AExp.optimize_0plus"><span class="id" type="definition">optimize_0plus</span></a> <a class="idref" href="Imp.html#a"><span class="id" type="variable">a</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#AExp.aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#a"><span class="id" type="variable">a</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">a</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">a</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "ANum". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "APlus". <span class="id" type="tactic">destruct</span> <span class="id" type="var">a1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "a1 = ANum n". <span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SSCase</span> "n = 0". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHa2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SSCase</span> "n &lt;&gt; 0". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa2</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "a1 = APlus a1_1 a1_2".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">IHa1</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa2</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "a1 = AMinus a1_1 a1_2".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">IHa1</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa2</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "a1 = AMult a1_1 a1_2".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">IHa1</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa2</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "AMinus".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa1</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa2</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "AMult".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa1</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa2</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab396"></a><h1 class="section">Coq Automation</h1>
 <a name="automation"/> *)

(** The repetition in this last proof is starting to be a little
    annoying.  If either the language of arithmetic expressions or the
    optimization being proved sound were significantly more complex,
    it would begin to be a real problem.

    So far, we've been doing all our proofs using just a small handful
    of Coq's tactics and completely ignoring its powerful facilities
    for constructing parts of proofs automatically.  This section
    introduces some of these facilities, and we will see more over the
    next several chapters.  Getting used to them will take some
    energy -- Coq's automation is a power tool -- but it will allow us
    to scale up our efforts to more complex definitions and more
    interesting properties without becoming overwhelmed by boring,
    repetitive, low-level details. *)

(* ########################### <a name="lab397"></a><h2 class="section">Tacticals</h2>

<div class="paragraph"> </div>

 <i>Tacticals</i> is Coq's term for tactics that take other tactics as
    arguments -- "higher-order tactics," if you will.  
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab398"></a><h3 class="section">The <span class="inlinecode"><span class="id" type="tactic">repeat</span></span> Tactical</h3>
 <a name="repeat"/> *)

(** The [repeat] tactical takes another tactic and keeps applying
    this tactic until the tactic fails. Here is an example showing
    that [100] is even using repeat. *)

Theorem ev100 : ev 100.
Proof.
  repeat (apply ev_SS). (* applies ev_SS 50 times,
                           until [apply ev_SS] fails *)
  apply ev_0.
Qed.
(* Print ev100. *)

(** The [repeat T] tactic never fails; if the tactic [T] doesn't apply
    to the original goal, then repeat still succeeds without changing
    the original goal (it repeats zero times). *)

Theorem ev100' : ev 100.
Proof.
  repeat (apply ev_0). (* doesn't fail, applies ev_0 zero times *)
  repeat (apply ev_SS). apply ev_0. (* we can continue the proof *)
Qed.

(** The [repeat T] tactic does not have any bound on the number of
    times it applies [T]. If [T] is a tactic that always succeeds then
    repeat [T] will loop forever (e.g. [repeat simpl] loops forever
    since [simpl] always succeeds). While Coq's term language is
    guaranteed to terminate, Coq's tactic language is not! *)

(* ########################### <a name="lab399"></a><h3 class="section">The <span class="inlinecode"><span class="id" type="tactic">try</span></span> Tactical</h3>
 <a name="try"/> *)

(** If [T] is a tactic, then [try T] is a tactic that is just like [T]
    except that, if [T] fails, [try T] _successfully_ does nothing at
    all (instead of failing). *)

Theorem silly1 : forall ae, aeval ae = aeval ae.
Proof. try reflexivity. (* this just does [reflexivity] *) Qed.

Theorem silly2 : forall (P : Prop), P -> P.
Proof.
  intros P HP.
  try reflexivity. (* just [reflexivity] would have failed *)
  apply HP. (* we can still finish the proof in some other way *)
Qed.

(** Using [try] in a completely manual proof is a bit silly, but
    we'll see below that [try] is very useful for doing automated
    proofs in conjunction with the [;] tactical. *)

(* ########################### <a name="lab400"></a><h3 class="section">The <span class="inlinecode">;</span> Tactical (Simple Form)</h3>
 <a name="sequence"/> *)

(** In its most commonly used form, the [;] tactical takes two tactics
    as argument: [T;T'] first performs the tactic [T] and then
    performs the tactic [T'] on _each subgoal_ generated by [T]. *)

(** For example, consider the following trivial lemma: *)

Lemma foo : forall n, ble_nat 0 n = true.
Proof.
  intros.
  destruct n.
    (* Leaves two subgoals, which are discharged identically...  *)
    Case "n=0". simpl. reflexivity.
    Case "n=Sn'". simpl. reflexivity.
Qed.

(** We can simplify this proof using the [;] tactical: *)

Lemma foo' : forall n, ble_nat 0 n = true.
Proof.
  intros.
  destruct n; (* [destruct] the current goal *)
  simpl; (* then [simpl] each resulting subgoal *)
  reflexivity. (* and do [reflexivity] on each resulting subgoal *)
Qed.

(** Using [try] and [;] together, we can get rid of the repetition in
    the proof that was bothering us a little while ago. *)

Theorem optimize_0plus_sound': forall a,
  aeval (optimize_0plus a) = aeval a.
Proof.
  intros a.
  induction a;
    (* Most cases follow directly by the IH *)
    try (simpl; rewrite IHa1; rewrite IHa2; reflexivity).
  (* The remaining cases -- ANum and APlus -- are different *)
  Case "ANum". reflexivity.
  Case "APlus".
    destruct a1;
      (* Again, most cases follow directly by the IH *)
      try (simpl; simpl in IHa1; rewrite IHa1;
           rewrite IHa2; reflexivity).
    (* The interesting case, on which the [try...] does nothing,
       is when [e1 = ANum n]. In this case, we have to destruct
       [n] (to see whether the optimization applies) and rewrite
       with the induction hypothesis. *)
    SCase "a1 = ANum n". destruct n;
      simpl; rewrite IHa2; reflexivity.   Qed.

(** Coq experts often use this "[...; try... ]" idiom after a tactic
    like [induction] to take care of many similar cases all at once.
    Naturally, this practice has an analog in informal proofs.

    Here is an informal proof of this theorem that matches the
    structure of the formal one:

    _Theorem_: For all arithmetic expressions [a],
       aeval (optimize_0plus a) = aeval a.
    _Proof_: By induction on [a].  The [AMinus] and [AMult] cases
    follow directly from the IH.  The remaining cases are as follows:

      - Suppose [a = ANum n] for some [n].  We must show
          aeval (optimize_0plus (ANum n)) = aeval (ANum n).
        This is immediate from the definition of [optimize_0plus].

      - Suppose [a = APlus a1 a2] for some [a1] and [a2].  We
        must show
          aeval (optimize_0plus (APlus a1 a2))
        = aeval (APlus a1 a2).
        Consider the possible forms of [a1].  For most of them,
        [optimize_0plus] simply calls itself recursively for the
        subexpressions and rebuilds a new expression of the same form
        as [a1]; in these cases, the result follows directly from the
        IH.

        The interesting case is when [a1 = ANum n] for some [n].
        If [n = ANum 0], then
          optimize_0plus (APlus a1 a2) = optimize_0plus a2
        and the IH for [a2] is exactly what we need.  On the other
        hand, if [n = S n'] for some [n'], then again [optimize_0plus]
        simply calls itself recursively, and the result follows from
        the IH.  [] *)

(** This proof can still be improved: the first case (for [a = ANum
    n]) is very trivial -- even more trivial than the cases that we
    said simply followed from the IH -- yet we have chosen to write it
    out in full.  It would be better and clearer to drop it and just
    say, at the top, "Most cases are either immediate or direct from
    the IH.  The only interesting case is the one for [APlus]..."  We
    can make the same improvement in our formal proof too.  Here's how
    it looks: *)

Theorem optimize_0plus_sound'': forall a,
  aeval (optimize_0plus a) = aeval a.
Proof.
  intros a.
  induction a;
    (* Most cases follow directly by the IH *)
    try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);
    (* ... or are immediate by definition *)
    try reflexivity.
  (* The interesting case is when a = APlus a1 a2. *)
  Case "APlus".
    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;
                      rewrite IHa2; reflexivity).
    SCase "a1 = ANum n". destruct n;
      simpl; rewrite IHa2; reflexivity. Qed.

(* ########################### <a name="lab401"></a><h3 class="section">The <span class="inlinecode">;</span> Tactical (General Form)</h3>
 <a name="sequence-general"/> *)

(** The [;] tactical has a more general than the simple [T;T'] we've
    seen above, which is sometimes also useful.  If [T], [T1], ...,
    [Tn] are tactics, then
      T; [T1 | T2 | ... | Tn]
   is a tactic that first performs [T] and then performs [T1] on the
   first subgoal generated by [T], performs [T2] on the second
   subgoal, etc.

   So [T;T'] is just special notation for the case when all of the
   [Ti]'s are the same tactic; i.e. [T;T'] is just a shorthand for:
      T; [T' | T' | ... | T']
*)

(* ########################### <a name="lab402"></a><h2 class="section">Defining New Tactic Notations</h2>
 <a name="tactic-notation"/> *)

(** Coq also provides several ways of "programming" tactic scripts.

      - The [Tactic Notation] idiom illustrated below gives a handy
        way to define "shorthand tactics" that bundle several tactics
        into a single command.

      - For more sophisticated programming, Coq offers a small
        built-in programming language called [Ltac] with primitives
        that can examine and modify the proof state.  The details are
        a bit too complicated to get into here (and it is generally
        agreed that [Ltac] is not the most beautiful part of Coq's
        design!), but they can be found in the reference manual, and
        there are many examples of [Ltac] definitions in the Coq
        standard library that you can use as examples.

      - There is also an OCaml API, which can be used to build tactics
        that access Coq's internal structures at a lower level, but
        this is seldom worth the trouble for ordinary Coq users.

The [Tactic Notation] mechanism is the easiest to come to grips with,
and it offers plenty of power for many purposes.  Here's an example.
*)

Tactic Notation "simpl_and_try" tactic(c) :=
  simpl;
  try c.

(** This defines a new tactical called [simpl_and_try] which
    takes one tactic [c] as an argument, and is defined to be
    equivalent to the tactic [simpl; try c].  For example, writing
    "[simpl_and_try reflexivity.]" in a proof would be the same as
    writing "[simpl; try reflexivity.]" *)

(** The next subsection gives a more sophisticated use of this
    feature... *)

(* ########################### <a name="lab403"></a><h3 class="section">Bulletproofing Case Analyses</h3>

<div class="paragraph"> </div>

 Being able to deal with most of the cases of an <span class="inlinecode"><span class="id" type="tactic">induction</span></span>
    or <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> all at the same time is very convenient, but it can
    also be a little confusing.  One problem that often comes up is
    that <i>maintaining</i> proofs written in this style can be difficult.
    For example, suppose that, later, we extended the definition of
    <span class="inlinecode"><a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a></span> with another constructor that also required a special
    argument.  The above proof might break because Coq generated the
    subgoals for this constructor before the one for <span class="inlinecode"><a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a></span>, so that,
    at the point when we start working on the <span class="inlinecode"><a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a></span> case, Coq is
    actually expecting the argument for a completely different
    constructor.  What we'd like is to get a sensible error message
    saying "I was expecting the <span class="inlinecode"><span class="id" type="var">AFoo</span></span> case at this point, but the
    proof script is talking about <span class="inlinecode"><a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a></span>."  Here's a nice trick (due
    to Aaron Bohannon) that smoothly achieves this. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Tactic Notation</span> "aexp_cases" <span class="id" type="var">tactic</span>(<span class="id" type="tactic">first</span>) <span class="id" type="var">ident</span>(<span class="id" type="var">c</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span>;<br/>
&nbsp;&nbsp;[ <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "ANum" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "APlus"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "AMinus" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "AMult" ].<br/>

<br/>
</div>

<div class="doc">
(<span class="inlinecode"><span class="id" type="var">Case_aux</span></span> implements the common functionality of <span class="inlinecode"><span class="id" type="var">Case</span></span>,
    <span class="inlinecode"><span class="id" type="var">SCase</span></span>, <span class="inlinecode"><span class="id" type="var">SSCase</span></span>, etc.  For example, <span class="inlinecode"><span class="id" type="var">Case</span></span> <span class="inlinecode">"<a class="idref" href="Imp.html#AExp.foo"><span class="id" type="lemma">foo</span></a>"</span> is defined as
    <span class="inlinecode"><span class="id" type="var">Case_aux</span></span> <span class="inlinecode"><span class="id" type="var">Case</span></span> <span class="inlinecode">"<a class="idref" href="Imp.html#AExp.foo"><span class="id" type="lemma">foo</span></a>".)</span> <span class="inlinecode"></span>
<div class="paragraph"> </div>

 For example, if <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.a"><span class="id" type="abbreviation">a</span></a></span> is a variable of type <span class="inlinecode"><a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a></span>, then doing
      aexp_cases (induction a) Case
    will perform an induction on <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.a"><span class="id" type="abbreviation">a</span></a></span> (the same as if we had just typed
    <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.a"><span class="id" type="abbreviation">a</span></a></span>) and <i>also</i> add a <span class="inlinecode"><span class="id" type="var">Case</span></span> tag to each subgoal
    generated by the <span class="inlinecode"><span class="id" type="tactic">induction</span></span>, labeling which constructor it comes
    from.  For example, here is yet another proof of
    <span class="inlinecode"><a class="idref" href="Imp.html#AExp.optimize_0plus_sound"><span class="id" type="lemma">optimize_0plus_sound</span></a></span>, using <span class="inlinecode"><span class="id" type="var">aexp_cases</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="AExp.optimize_0plus_sound'''"><span class="id" type="lemma">optimize_0plus_sound'''</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#AExp.aeval"><span class="id" type="definition">aeval</span></a> (<a class="idref" href="Imp.html#AExp.optimize_0plus"><span class="id" type="definition">optimize_0plus</span></a> <a class="idref" href="Imp.html#a"><span class="id" type="variable">a</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#AExp.aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#a"><span class="id" type="variable">a</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">a</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">aexp_cases</span> (<span class="id" type="tactic">induction</span> <span class="id" type="var">a</span>) <span class="id" type="var">Case</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> (<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa1</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa2</span>; <span class="id" type="tactic">reflexivity</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "APlus".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">aexp_cases</span> (<span class="id" type="tactic">destruct</span> <span class="id" type="var">a1</span>) <span class="id" type="var">SCase</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> (<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">IHa1</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa1</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa2</span>; <span class="id" type="tactic">reflexivity</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "ANum". <span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa2</span>; <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab404"></a><h4 class="section">Exercise: 3 stars (optimize_0plus_b)</h4>
 Since the <span class="inlinecode"><a class="idref" href="Imp.html#AExp.optimize_0plus"><span class="id" type="definition">optimize_0plus</span></a></span> tranformation doesn't change the value
    of <span class="inlinecode"><a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a></span>s, we should be able to apply it to all the <span class="inlinecode"><a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a></span>s that
    appear in a <span class="inlinecode"><a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a></span> without changing the <span class="inlinecode"><a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a></span>'s value.  Write a
    function which performs that transformation on <span class="inlinecode"><a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a></span>s, and prove
    it is sound.  Use the tacticals we've just seen to make the proof
    as elegant as possible. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="AExp.optimize_0plus_b"><span class="id" type="definition">optimize_0plus_b</span></a> (<span class="id" type="var">b</span> : <a class="idref" href="Imp.html#AExp.bexp"><span class="id" type="inductive">bexp</span></a>) : <a class="idref" href="Imp.html#AExp.bexp"><span class="id" type="inductive">bexp</span></a> :=<br/>
&nbsp;&nbsp; <a class="idref" href="SfLib.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="AExp.optimize_0plus_b_sound"><span class="id" type="lemma">optimize_0plus_b_sound</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#AExp.beval"><span class="id" type="definition">beval</span></a> (<a class="idref" href="Imp.html#AExp.optimize_0plus_b"><span class="id" type="definition">optimize_0plus_b</span></a> <a class="idref" href="Imp.html#b"><span class="id" type="variable">b</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#AExp.beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Imp.html#b"><span class="id" type="variable">b</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab405"></a><h4 class="section">Exercise: 4 stars, optional (optimizer)</h4>
 <i>Design exercise</i>: The optimization implemented by our
    <span class="inlinecode"><a class="idref" href="Imp.html#AExp.optimize_0plus"><span class="id" type="definition">optimize_0plus</span></a></span> function is only one of many imaginable
    optimizations on arithmetic and boolean expressions.  Write a more
    sophisticated optimizer and prove it correct.

<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab406"></a><h2 class="section">The <span class="inlinecode"><span class="id" type="tactic">omega</span></span> Tactic</h2>
 <a name="omega"/> *)

(** The [omega] tactic implements a decision procedure for a subset of
    first-order logic called _Presburger arithmetic_.  It is based on
    the Omega algorithm invented in 1992 by William Pugh.

    If the goal is a universally quantified formula made out of

      - numeric constants, addition ([+] and [S]), subtraction ([-]
        and [pred]), and multiplication by constants (this is what
        makes it Presburger arithmetic),

      - equality ([=] and [<>]) and inequality ([<=]), and

      - the logical connectives [/\], [\/], [~], and [->],

    then invoking [omega] will either solve the goal or tell you that
    it is actually false. *)

Example silly_presburger_example : forall m n o p,
  m + n <= n + o /\ o + 3 = p + 3 ->
  m <= p.
Proof.
  intros. omega.
Qed.

(** Liebniz wrote, "It is unworthy of excellent men to lose
    hours like slaves in the labor of calculation which could be
    relegated to anyone else if machines were used."  We recommend
    using the omega tactic whenever possible. *)

(* ########################### <a name="lab407"></a><h2 class="section">A Few More Handy Tactics</h2>
 <a name="more-tactics"/> *)

(** Finally, here are some miscellaneous tactics that you may find
    convenient.

     - [clear H]: Delete hypothesis [H] from the context.

     - [subst x]: Find an assumption [x = e] or [e = x] in the
       context, replace [x] with [e] throughout the context and
       current goal, and clear the assumption.

     - [subst]: Substitute away _all_ assumptions of the form [x = e]
       or [e = x].

     - [rename... into...]: Change the name of a hypothesis in the
       proof context.  For example, if the context includes a variable
       named [x], then [rename x into y] will change all occurrences
       of [x] to [y].

     - [assumption]: Try to find a hypothesis [H] in the context that
       exactly matches the goal; if one is found, behave just like
       [apply H].

     - [contradiction]: Try to find a hypothesis [H] in the current
       context that is logically equivalent to [False].  If one is
       found, solve the goal.

     - [constructor]: Try to find a constructor [c] (from some
       [Inductive] definition in the current environment) that can be
       applied to solve the current goal.  If one is found, behave
       like [apply c]. *)

(** We'll see many examples of these in the proofs below. *)

(* ########################### <a name="lab408"></a><h1 class="section">Evaluation as a Relation</h1>
 <a name="evaluationrelation"/> *)

(** We have presented [aeval] and [beval] as functions defined by
    [Fixpoints].  Another way to think about evaluation -- one that we
    will see is often more flexible -- is as a _relation_ between
    expressions and their values.  This leads naturally to [Inductive]
    definitions like the following one for arithmetic
    expressions... *)

Module aevalR_first_try.

Inductive aevalR : aexp -> nat -> Prop :=
  | E_ANum  : forall (n: nat),
      aevalR (ANum n) n
  | E_APlus : forall (e1 e2: aexp) (n1 n2: nat),
      aevalR e1 n1 ->
      aevalR e2 n2 ->
      aevalR (APlus e1 e2) (n1 + n2)
  | E_AMinus: forall (e1 e2: aexp) (n1 n2: nat),
      aevalR e1 n1 ->
      aevalR e2 n2 ->
      aevalR (AMinus e1 e2) (n1 - n2)
  | E_AMult : forall (e1 e2: aexp) (n1 n2: nat),
      aevalR e1 n1 ->
      aevalR e2 n2 ->
      aevalR (AMult e1 e2) (n1 * n2).

(** As is often the case with relations, we'll find it
    convenient to define infix notation for [aevalR].  We'll write [e
    || n] to mean that arithmetic expression [e] evaluates to value
    [n].  (This notation is one place where the limitation to ASCII
    symbols becomes a little bothersome.  The standard notation for
    the evaluation relation is a double down-arrow.  We'll typeset it
    like this in the HTML version of the notes and use a double
    vertical bar as the closest approximation in [.v] files.)  *)

Notation "e '||' n" := (aevalR e n) : type_scope.

End aevalR_first_try.

(** In fact, Coq provides a way to use this notation in the definition
    of [aevalR] itself.  This avoids situations where we're working on
    a proof involving statements in the form [e || n] but we have to
    refer back to a definition written using the form [aevalR e n].

    We do this by first "reserving" the notation, then giving the
    definition together with a declaration of what the notation
    means. *)

Reserved Notation "e '||' n" (at level 50, left associativity).

Inductive aevalR : aexp -> nat -> Prop :=
  | E_ANum : forall (n:nat),
      (ANum n) || n
  | E_APlus : forall (e1 e2: aexp) (n1 n2 : nat),
      (e1 || n1) -> (e2 || n2) -> (APlus e1 e2) || (n1 + n2)
  | E_AMinus : forall (e1 e2: aexp) (n1 n2 : nat),
      (e1 || n1) -> (e2 || n2) -> (AMinus e1 e2) || (n1 - n2)
  | E_AMult :  forall (e1 e2: aexp) (n1 n2 : nat),
      (e1 || n1) -> (e2 || n2) -> (AMult e1 e2) || (n1 * n2)

  where "e '||' n" := (aevalR e n) : type_scope.

Tactic Notation "aevalR_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "E_ANum" | Case_aux c "E_APlus"
  | Case_aux c "E_AMinus" | Case_aux c "E_AMult" ].

(* ########################### <a name="lab409"></a><h2 class="section">Inference Rule Notation</h2>
 <a name="inferencerules"/> *)

(** In informal discussions, it is convenient write the rules for
    [aevalR] and similar relations in the more readable graphical form
    of _inference rules_, where the premises above the line justify
    the conclusion below the line (we have already seen them in the
    Prop chapter). *)

(** For example, the constructor [E_APlus]...
      | E_APlus : forall (e1 e2: aexp) (n1 n2: nat),
          aevalR e1 n1 ->
          aevalR e2 n2 ->
          aevalR (APlus e1 e2) (n1 + n2)
    ...would be written like this as an inference rule:
                               e1 || n1
                               e2 || n2
                         --------------------                         (E_APlus)
                         APlus e1 e2 || n1+n2
*)

(** Formally, there is nothing very deep about inference rules:
    they are just implications.  You can read the rule name on the
    right as the name of the constructor and read each of the
    linebreaks between the premises above the line and the line itself
    as [->].  All the variables mentioned in the rule ([e1], [n1],
    etc.) are implicitly bound by universal quantifiers at the
    beginning. (Such variables are often called _metavariables_ to
    distinguish them from the variables of the language we are
    defining.  At the moment, our arithmetic expressions don't include
    variables, but we'll soon be adding them.)  The whole collection
    of rules is understood as being wrapped in an [Inductive]
    declaration (informally, this is either elided or else indicated
    by saying something like "Let [aevalR] be the smallest relation
    closed under the following rules..."). *)

(** For example, [||] is the smallest relation closed under these
    rules:
                             -----------                               (E_ANum)
                             ANum n || n

                               e1 || n1
                               e2 || n2
                         --------------------                         (E_APlus)
                         APlus e1 e2 || n1+n2

                               e1 || n1
                               e2 || n2
                        ---------------------                        (E_AMinus)
                        AMinus e1 e2 || n1-n2

                               e1 || n1
                               e2 || n2
                         --------------------                         (E_AMult)
                         AMult e1 e2 || n1*n2
*)



(* ########################### <a name="lab410"></a><h2 class="section">Equivalence of the Definitions</h2>

<div class="paragraph"> </div>

 It is straightforward to prove that the relational and functional
    definitions of evaluation agree on all possible arithmetic
    expressions... 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="AExp.aeval_iff_aevalR"><span class="id" type="lemma">aeval_iff_aevalR</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Imp.html#AExp.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="Imp.html#AExp.aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;<span class="id" type="var">Case</span> "-&gt;".<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">aevalR_cases</span> (<span class="id" type="tactic">induction</span> <span class="id" type="var">H</span>) <span class="id" type="var">SCase</span>; <span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "E_ANum".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "E_APlus".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHaevalR1</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHaevalR2</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "E_AMinus".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHaevalR1</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHaevalR2</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "E_AMult".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHaevalR1</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHaevalR2</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;<span class="id" type="var">Case</span> "&lt;-".<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">aexp_cases</span> (<span class="id" type="tactic">induction</span> <span class="id" type="var">a</span>) <span class="id" type="var">SCase</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "ANum".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#AExp.E_ANum"><span class="id" type="constructor">E_ANum</span></a>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "APlus".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#AExp.E_APlus"><span class="id" type="constructor">E_APlus</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHa1</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHa2</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "AMinus".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#AExp.E_AMinus"><span class="id" type="constructor">E_AMinus</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHa1</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHa2</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "AMult".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#AExp.E_AMult"><span class="id" type="constructor">E_AMult</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHa1</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHa2</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Note: if you're reading the HTML file, you'll see an empty square box instead
of a proof for this theorem.  
You can click on this box to "unfold" the text to see the proof.
Click on the unfolded to text to "fold" it back up to a box. We'll be using
this style frequently from now on to help keep the HTML easier to read.
The full proofs always appear in the .v files. 
<div class="paragraph"> </div>

 We can make the proof quite a bit shorter by making more
    use of tacticals... 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="AExp.aeval_iff_aevalR'"><span class="id" type="lemma">aeval_iff_aevalR'</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Imp.html#AExp.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="Imp.html#AExp.aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "-&gt;".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "&lt;-".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">a</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">constructor</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">IHa1</span>; <span class="id" type="tactic">try</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">IHa2</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab411"></a><h4 class="section">Exercise: 3 stars  (bevalR)</h4>
 Write a relation <span class="inlinecode"><span class="id" type="var">bevalR</span></span> in the same style as
    <span class="inlinecode"><a class="idref" href="Imp.html#aevalR_extended.aevalR"><span class="id" type="inductive">aevalR</span></a></span>, and prove that it is equivalent to <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span>.
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">
<span class="id" type="keyword">End</span> <a class="idref" href="Imp.html#AExp"><span class="id" type="module">AExp</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab412"></a><h2 class="section">Computational vs. Relational Definitions</h2>

<div class="paragraph"> </div>

 For the definitions of evaluation for arithmetic and boolean
    expressions, the choice of whether to use functional or relational
    definitions is mainly a matter of taste.  In general, Coq has
    somewhat better support for working with relations.  On the other
    hand, in some sense function definitions carry more information,
    because functions are necessarily deterministic and defined on all
    arguments; for a relation we have to show these properties
    explicitly if we need them. Functions also take advantage of Coq's
    computations mechanism.

<div class="paragraph"> </div>

    However, there are circumstances where relational definitions of
    evaluation are preferable to functional ones.  
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Module</span> <a name="aevalR_division"><span class="id" type="module">aevalR_division</span></a>.<br/>

<br/>
</div>

<div class="doc">
For example, suppose that we wanted to extend the arithmetic
    operations by considering also a division operation:
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="aevalR_division.aexp"><span class="id" type="inductive">aexp</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="aevalR_division.ANum"><span class="id" type="constructor">ANum</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a><br/>
&nbsp;&nbsp;| <a name="aevalR_division.APlus"><span class="id" type="constructor">APlus</span></a> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a><br/>
&nbsp;&nbsp;| <a name="aevalR_division.AMinus"><span class="id" type="constructor">AMinus</span></a> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a><br/>
&nbsp;&nbsp;| <a name="aevalR_division.AMult"><span class="id" type="constructor">AMult</span></a> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a><br/>
&nbsp;&nbsp;| <a name="aevalR_division.ADiv"><span class="id" type="constructor">ADiv</span></a> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>. 
<br/>
</div>

<div class="doc">
Extending the definition of <span class="inlinecode"><a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a></span> to handle this new operation
    would not be straightforward (what should we return as the result
    of <span class="inlinecode"><a class="idref" href="Imp.html#aevalR_division.ADiv"><span class="id" type="constructor">ADiv</span></a></span> <span class="inlinecode">(<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a></span> <span class="inlinecode">5)</span> <span class="inlinecode">(<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a></span> <span class="inlinecode">0)</span>?).  But extending <span class="inlinecode"><a class="idref" href="Imp.html#aevalR_extended.aevalR"><span class="id" type="inductive">aevalR</span></a></span> is
    straightforward. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="aevalR_division.aevalR"><span class="id" type="inductive">aevalR</span></a> : <a class="idref" href="Imp.html#aevalR_division.aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="aevalR_division.E_ANum"><span class="id" type="constructor">E_ANum</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#aevalR_division.ANum"><span class="id" type="constructor">ANum</span></a> <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a><a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a><br/>
&nbsp;&nbsp;| <a name="aevalR_division.E_APlus"><span class="id" type="constructor">E_APlus</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">a1</span> <span class="id" type="var">a2</span>: <a class="idref" href="Imp.html#aevalR_division.aexp"><span class="id" type="inductive">aexp</span></a>) (<span class="id" type="var">n1</span> <span class="id" type="var">n2</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a>) → (<a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a>) → <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#aevalR_division.APlus"><span class="id" type="constructor">APlus</span></a> <a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a><a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a><a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;| <a name="aevalR_division.E_AMinus"><span class="id" type="constructor">E_AMinus</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">a1</span> <span class="id" type="var">a2</span>: <a class="idref" href="Imp.html#aevalR_division.aexp"><span class="id" type="inductive">aexp</span></a>) (<span class="id" type="var">n1</span> <span class="id" type="var">n2</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a>) → (<a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a>) → <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#aevalR_division.AMinus"><span class="id" type="constructor">AMinus</span></a> <a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a><a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a><a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;| <a name="aevalR_division.E_AMult"><span class="id" type="constructor">E_AMult</span></a> :  <span class="id" type="keyword">∀</span> (<span class="id" type="var">a1</span> <span class="id" type="var">a2</span>: <a class="idref" href="Imp.html#aevalR_division.aexp"><span class="id" type="inductive">aexp</span></a>) (<span class="id" type="var">n1</span> <span class="id" type="var">n2</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a>) → (<a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a>) → <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#aevalR_division.AMult"><span class="id" type="constructor">AMult</span></a> <a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a><a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a><a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;| <a name="aevalR_division.E_ADiv"><span class="id" type="constructor">E_ADiv</span></a> :  <span class="id" type="keyword">∀</span> (<span class="id" type="var">a1</span> <span class="id" type="var">a2</span>: <a class="idref" href="Imp.html#aevalR_division.aexp"><span class="id" type="inductive">aexp</span></a>) (<span class="id" type="var">n1</span> <span class="id" type="var">n2</span> <span class="id" type="var">n3</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a>) → (<a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a>) → (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#mult"><span class="id" type="definition">mult</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a> <a class="idref" href="Imp.html#n3"><span class="id" type="variable">n3</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a>) → <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#aevalR_division.ADiv"><span class="id" type="constructor">ADiv</span></a> <a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a><a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n3"><span class="id" type="variable">n3</span></a><br/>
<br/>
<span class="id" type="keyword">where</span> <a name="aevalR_division.:type_scope:x_'||'_x"><span class="id" type="notation">"</span></a>a '||' n" := (<a class="idref" href="Imp.html#aevalR"><span class="id" type="inductive">aevalR</span></a> <span class="id" type="var">a</span> <span class="id" type="var">n</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Imp.html#aevalR_division"><span class="id" type="module">aevalR_division</span></a>.<br/>
<span class="id" type="keyword">Module</span> <a name="aevalR_extended"><span class="id" type="module">aevalR_extended</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab413"></a><h3 class="section">Adding nondeterminism</h3>

</div>
<div class="code">
</div>

<div class="doc">
Suppose, instead, that we want to extend the arithmetic operations
    by a nondeterministic number generator <span class="inlinecode"><span class="id" type="var">any</span></span>:
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="aevalR_extended.aexp"><span class="id" type="inductive">aexp</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="aevalR_extended.AAny"><span class="id" type="constructor">AAny</span></a>  : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>                   <br/>
&nbsp;&nbsp;| <a name="aevalR_extended.ANum"><span class="id" type="constructor">ANum</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a><br/>
&nbsp;&nbsp;| <a name="aevalR_extended.APlus"><span class="id" type="constructor">APlus</span></a> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a><br/>
&nbsp;&nbsp;| <a name="aevalR_extended.AMinus"><span class="id" type="constructor">AMinus</span></a> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a><br/>
&nbsp;&nbsp;| <a name="aevalR_extended.AMult"><span class="id" type="constructor">AMult</span></a> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>.<br/>

<br/>
</div>

<div class="doc">
Again, extending <span class="inlinecode"><a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a></span> would be tricky (because evaluation is
    <i>not</i> a deterministic function from expressions to numbers), but
    extending <span class="inlinecode"><a class="idref" href="Imp.html#aevalR_extended.aevalR"><span class="id" type="inductive">aevalR</span></a></span> is no problem: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="aevalR_extended.aevalR"><span class="id" type="inductive">aevalR</span></a> : <a class="idref" href="Imp.html#aevalR_extended.aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="aevalR_extended.E_Any"><span class="id" type="constructor">E_Any</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#aevalR_extended.AAny"><span class="id" type="constructor">AAny</span></a> <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a>                 <br/>
&nbsp;&nbsp;| <a name="aevalR_extended.E_ANum"><span class="id" type="constructor">E_ANum</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#aevalR_extended.ANum"><span class="id" type="constructor">ANum</span></a> <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a><a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a><br/>
&nbsp;&nbsp;| <a name="aevalR_extended.E_APlus"><span class="id" type="constructor">E_APlus</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">a1</span> <span class="id" type="var">a2</span>: <a class="idref" href="Imp.html#aevalR_extended.aexp"><span class="id" type="inductive">aexp</span></a>) (<span class="id" type="var">n1</span> <span class="id" type="var">n2</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a>) → (<a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a> <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a>) → <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#aevalR_extended.APlus"><span class="id" type="constructor">APlus</span></a> <a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a><a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a><a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;| <a name="aevalR_extended.E_AMinus"><span class="id" type="constructor">E_AMinus</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">a1</span> <span class="id" type="var">a2</span>: <a class="idref" href="Imp.html#aevalR_extended.aexp"><span class="id" type="inductive">aexp</span></a>) (<span class="id" type="var">n1</span> <span class="id" type="var">n2</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a>) → (<a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a> <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a>) → <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#aevalR_extended.AMinus"><span class="id" type="constructor">AMinus</span></a> <a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a><a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a><a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;| <a name="aevalR_extended.E_AMult"><span class="id" type="constructor">E_AMult</span></a> :  <span class="id" type="keyword">∀</span> (<span class="id" type="var">a1</span> <span class="id" type="var">a2</span>: <a class="idref" href="Imp.html#aevalR_extended.aexp"><span class="id" type="inductive">aexp</span></a>) (<span class="id" type="var">n1</span> <span class="id" type="var">n2</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a>) → (<a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a> <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a>) → <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#aevalR_extended.AMult"><span class="id" type="constructor">AMult</span></a> <a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a><a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a><a class="idref" href="Imp.html#aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">)</span></a><br/>
<br/>
<span class="id" type="keyword">where</span> <a name="aevalR_extended.:type_scope:x_'||'_x"><span class="id" type="notation">"</span></a>a '||' n" := (<a class="idref" href="Imp.html#aevalR"><span class="id" type="inductive">aevalR</span></a> <span class="id" type="var">a</span> <span class="id" type="var">n</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Imp.html#aevalR_extended"><span class="id" type="module">aevalR_extended</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab414"></a><h1 class="section">Expressions With Variables</h1>

<div class="paragraph"> </div>

 Let's turn our attention back to defining Imp.  The next thing we
    need to do is to enrich our arithmetic and boolean expressions
    with variables.  To keep things simple, we'll assume that all
    variables are global and that they only hold numbers. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab415"></a><h2 class="section">Identifiers</h2>

<div class="paragraph"> </div>

 To begin, we'll need to formalize <i>identifiers</i> such as program
    variables.  We could use strings for this -- or, in a real
    compiler, fancier structures like pointers into a symbol table.
    But for simplicity let's just use natural numbers as identifiers. 
<div class="paragraph"> </div>

 (We hide this section in a module because these definitions are
    actually in <span class="inlinecode"><a class="idref" href="SfLib.html#"><span class="id" type="library">SfLib</span></a></span>, but we want to repeat them here so that we
    can explain them.) 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Module</span> <a name="Id"><span class="id" type="module">Id</span></a>.<br/>

<br/>
</div>

<div class="doc">
We define a new inductive datatype <span class="inlinecode"><a class="idref" href="Imp.html#Id.Id"><span class="id" type="constructor">Id</span></a></span> so that we won't confuse
    identifiers and numbers.  We use <span class="inlinecode"><a class="idref" href="MoreLogic.html#sumbool"><span class="id" type="inductive">sumbool</span></a></span> to define a computable
    equality operator on <span class="inlinecode"><a class="idref" href="Imp.html#Id.Id"><span class="id" type="constructor">Id</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="Id.id"><span class="id" type="inductive">id</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<a name="Id.Id"><span class="id" type="constructor">Id</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="Imp.html#id"><span class="id" type="inductive">id</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="Id.eq_id_dec"><span class="id" type="lemma">eq_id_dec</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">id1</span> <span class="id" type="var">id2</span> : <a class="idref" href="Imp.html#Id.id"><span class="id" type="inductive">id</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">{</span></a><a class="idref" href="Imp.html#id1"><span class="id" type="variable">id1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#id2"><span class="id" type="variable">id2</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">{</span></a><a class="idref" href="Imp.html#id1"><span class="id" type="variable">id1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<>'_x"><span class="id" type="notation">≠</span></a> <a class="idref" href="Imp.html#id2"><span class="id" type="variable">id2</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">id1</span> <span class="id" type="var">id2</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">id1</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">n1</span>]. <span class="id" type="tactic">destruct</span> <span class="id" type="var">id2</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">n2</span>].<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.Peano_dec.html#eq_nat_dec"><span class="id" type="lemma">eq_nat_dec</span></a> <span class="id" type="var">n1</span> <span class="id" type="var">n2</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">Heq</span> | <span class="id" type="var">Hneq</span>].<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "n1 = n2".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">left</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Heq</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "n1 &lt;&gt; n2".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">right</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">contra</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">Hneq</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H0</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The following lemmas will be useful for rewriting terms involving <span class="inlinecode"><a class="idref" href="Imp.html#Id.eq_id_dec"><span class="id" type="lemma">eq_id_dec</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="Id.eq_id"><span class="id" type="lemma">eq_id</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">T</span>:<span class="id" type="keyword">Type</span>) <span class="id" type="var">x</span> (<span class="id" type="var">p</span> <span class="id" type="var">q</span>:<a class="idref" href="Imp.html#T"><span class="id" type="variable">T</span></a>), <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">if</span> <a class="idref" href="Imp.html#Id.eq_id_dec"><span class="id" type="lemma">eq_id_dec</span></a> <a class="idref" href="Imp.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Imp.html#x"><span class="id" type="variable">x</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Imp.html#p"><span class="id" type="variable">p</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Imp.html#q"><span class="id" type="variable">q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#p"><span class="id" type="variable">p</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<a class="idref" href="Imp.html#Id.eq_id_dec"><span class="id" type="lemma">eq_id_dec</span></a> <span class="id" type="var">x</span> <span class="id" type="var">x</span>).<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "x = x".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "x &lt;&gt; x (impossible)".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="SfLib.html#ex_falso_quodlibet"><span class="id" type="lemma">ex_falso_quodlibet</span></a>; <span class="id" type="tactic">apply</span> <span class="id" type="var">n</span>; <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab416"></a><h4 class="section">Exercise: 1 star, optional (neq_id)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="Id.neq_id"><span class="id" type="lemma">neq_id</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">T</span>:<span class="id" type="keyword">Type</span>) <span class="id" type="var">x</span> <span class="id" type="var">y</span> (<span class="id" type="var">p</span> <span class="id" type="var">q</span>:<a class="idref" href="Imp.html#T"><span class="id" type="variable">T</span></a>), <a class="idref" href="Imp.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<>'_x"><span class="id" type="notation">≠</span></a> <a class="idref" href="Imp.html#y"><span class="id" type="variable">y</span></a> → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">if</span> <a class="idref" href="Imp.html#Id.eq_id_dec"><span class="id" type="lemma">eq_id_dec</span></a> <a class="idref" href="Imp.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Imp.html#y"><span class="id" type="variable">y</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Imp.html#p"><span class="id" type="variable">p</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Imp.html#q"><span class="id" type="variable">q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#q"><span class="id" type="variable">q</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Imp.html#Id"><span class="id" type="module">Id</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab417"></a><h2 class="section">States</h2>

<div class="paragraph"> </div>

 A <i>state</i> represents the current values of <i>all</i> the variables at
    some point in the execution of a program.  For simplicity (to avoid dealing with partial functions), we
    let the state be defined for <i>all</i> variables, even though any
    given program is only going to mention a finite number of them. 
    The state captures all of the information stored in memory.  For Imp
    programs, because each variable stores only a natural number, we
    can represent the state as a mapping from identifiers to <span class="inlinecode"><a class="idref" href="Basics.html#Playground1.nat"><span class="id" type="inductive">nat</span></a></span>.  
    For more complex programming languages, the state might have more 
    structure.  

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="state"><span class="id" type="definition">state</span></a> := <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="empty_state"><span class="id" type="definition">empty_state</span></a> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> ⇒ 0.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="update"><span class="id" type="definition">update</span></a> (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">x</span> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a>) (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> <span class="id" type="var">x'</span> ⇒ <span class="id" type="keyword">if</span> <a class="idref" href="SfLib.html#eq_id_dec"><span class="id" type="lemma">eq_id_dec</span></a> <a class="idref" href="Imp.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Imp.html#x'"><span class="id" type="variable">x'</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#x'"><span class="id" type="variable">x'</span></a>.<br/>

<br/>
</div>

<div class="doc">
For proofs involving states, we'll need several simple properties
    of <span class="inlinecode"><a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a></span>. 
<div class="paragraph"> </div>

<a name="lab418"></a><h4 class="section">Exercise: 1 star (update_eq)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="update_eq"><span class="id" type="lemma">update_eq</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> <span class="id" type="var">x</span> <span class="id" type="var">st</span>,<br/>
&nbsp;&nbsp;(<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a>) <a class="idref" href="Imp.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab419"></a><h4 class="section">Exercise: 1 star (update_neq)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="update_neq"><span class="id" type="lemma">update_neq</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x2</span> <span class="id" type="var">x1</span> <span class="id" type="var">n</span> <span class="id" type="var">st</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#x2"><span class="id" type="variable">x2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<>'_x"><span class="id" type="notation">≠</span></a> <a class="idref" href="Imp.html#x1"><span class="id" type="variable">x1</span></a> →                        <br/>
&nbsp;&nbsp;(<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#x2"><span class="id" type="variable">x2</span></a> <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a>) <a class="idref" href="Imp.html#x1"><span class="id" type="variable">x1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#x1"><span class="id" type="variable">x1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab420"></a><h4 class="section">Exercise: 1 star (update_example)</h4>
 Before starting to play with tactics, make sure you understand
    exactly what the theorem is saying! 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="update_example"><span class="id" type="lemma">update_example</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;(<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> (<a class="idref" href="SfLib.html#Id"><span class="id" type="constructor">Id</span></a> 2) <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a>) (<a class="idref" href="SfLib.html#Id"><span class="id" type="constructor">Id</span></a> 3) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab421"></a><h4 class="section">Exercise: 1 star (update_shadow)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="update_shadow"><span class="id" type="lemma">update_shadow</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n1</span> <span class="id" type="var">n2</span> <span class="id" type="var">x1</span> <span class="id" type="var">x2</span> (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>),<br/>
&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a>  (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#x2"><span class="id" type="variable">x2</span></a> <a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a>) <a class="idref" href="Imp.html#x2"><span class="id" type="variable">x2</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a>) <a class="idref" href="Imp.html#x1"><span class="id" type="variable">x1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#x2"><span class="id" type="variable">x2</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a>) <a class="idref" href="Imp.html#x1"><span class="id" type="variable">x1</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab422"></a><h4 class="section">Exercise: 2 stars (update_same)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="update_same"><span class="id" type="lemma">update_same</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n1</span> <span class="id" type="var">x1</span> <span class="id" type="var">x2</span> (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#x1"><span class="id" type="variable">x1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a> →<br/>
&nbsp;&nbsp;(<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#x1"><span class="id" type="variable">x1</span></a> <a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a>) <a class="idref" href="Imp.html#x2"><span class="id" type="variable">x2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#x2"><span class="id" type="variable">x2</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab423"></a><h4 class="section">Exercise: 3 stars (update_permute)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="update_permute"><span class="id" type="lemma">update_permute</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n1</span> <span class="id" type="var">n2</span> <span class="id" type="var">x1</span> <span class="id" type="var">x2</span> <span class="id" type="var">x3</span> <span class="id" type="var">st</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#x2"><span class="id" type="variable">x2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<>'_x"><span class="id" type="notation">≠</span></a> <a class="idref" href="Imp.html#x1"><span class="id" type="variable">x1</span></a> → <br/>
&nbsp;&nbsp;(<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#x2"><span class="id" type="variable">x2</span></a> <a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a>) <a class="idref" href="Imp.html#x1"><span class="id" type="variable">x1</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a>) <a class="idref" href="Imp.html#x3"><span class="id" type="variable">x3</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#x1"><span class="id" type="variable">x1</span></a> <a class="idref" href="Imp.html#n2"><span class="id" type="variable">n2</span></a>) <a class="idref" href="Imp.html#x2"><span class="id" type="variable">x2</span></a> <a class="idref" href="Imp.html#n1"><span class="id" type="variable">n1</span></a>) <a class="idref" href="Imp.html#x3"><span class="id" type="variable">x3</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab424"></a><h2 class="section">Syntax</h2>
 <a name="exp-id-syntax"/> *)

(** We can add variables to the arithmetic expressions we had before by
    simply adding one more constructor: *)

Inductive aexp : Type :=
  | ANum : nat -> aexp
  | AId : id -> aexp                (* <----- NEW *)
  | APlus : aexp -> aexp -> aexp
  | AMinus : aexp -> aexp -> aexp
  | AMult : aexp -> aexp -> aexp.

Tactic Notation "aexp_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "ANum" | Case_aux c "AId" | Case_aux c "APlus"
  | Case_aux c "AMinus" | Case_aux c "AMult" ].

(** Defining a few variable names as notational shorthands will make
    examples easier to read: *)

Definition X : id := Id 0.
Definition Y : id := Id 1.
Definition Z : id := Id 2.

(** (This convention for naming program variables ([X], [Y],
    [Z]) clashes a bit with our earlier use of uppercase letters for
    types.  Since we're not using polymorphism heavily in this part of
    the course, this overloading should not cause confusion.) *)

(** The definition of [bexp]s is the same as before (using the new
    [aexp]s): *)

Inductive bexp : Type :=
  | BTrue : bexp
  | BFalse : bexp
  | BEq : aexp -> aexp -> bexp
  | BLe : aexp -> aexp -> bexp
  | BNot : bexp -> bexp
  | BAnd : bexp -> bexp -> bexp.

Tactic Notation "bexp_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "BTrue" | Case_aux c "BFalse" | Case_aux c "BEq"
  | Case_aux c "BLe" | Case_aux c "BNot" | Case_aux c "BAnd" ].

(* ######################### <a name="lab425"></a><h2 class="section">Evaluation</h2>

<div class="paragraph"> </div>

 The arith and boolean evaluators can be extended to handle
    variables in the obvious way: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="aeval"><span class="id" type="definition">aeval</span></a> (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">a</span> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Imp.html#a"><span class="id" type="variable">a</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n</span> ⇒ <span class="id" type="var">n</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <span class="id" type="var">x</span> ⇒ <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">x</span>                                        <br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">a1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">a2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span>  ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">a1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">a2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#AMult"><span class="id" type="constructor">AMult</span></a> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">a1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">a2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="beval"><span class="id" type="definition">beval</span></a> (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">b</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Imp.html#b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a>       ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a>      ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span>   ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.EqNat.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> (<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">a1</span>) (<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">a2</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#BLe"><span class="id" type="constructor">BLe</span></a> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span>   ⇒ <a class="idref" href="SfLib.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> (<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">a1</span>) (<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">a2</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> <span class="id" type="var">b1</span>     ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> (<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">b1</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#BAnd"><span class="id" type="constructor">BAnd</span></a> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span>  ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#andb"><span class="id" type="definition">andb</span></a> (<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">b1</span>) (<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">b2</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="aexp1"><span class="id" type="definition">aexp1</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> 5)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 3) (<a class="idref" href="Imp.html#AMult"><span class="id" type="constructor">AMult</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 2)))<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 13.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="bexp1"><span class="id" type="definition">bexp1</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> 5)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#BAnd"><span class="id" type="constructor">BAnd</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> (<a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BLe"><span class="id" type="constructor">BLe</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 4))))<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab426"></a><h1 class="section">Commands</h1>

<div class="paragraph"> </div>

 Now we are ready define the syntax and behavior of Imp
    <i>commands</i> (often called <i>statements</i>). 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab427"></a><h2 class="section">Syntax</h2>
 <a name="cmd-syntax"/> *)

(** Informally, commands [c] are described by the following BNF
    grammar:
     c ::= SKIP
         | x ::= a
         | c ;; c
         | WHILE b DO c END
         | IFB b THEN c ELSE c FI
]] 
*)
(**
    For example, here's the factorial function in Imp.
     Z ::= X;;
     Y ::= 1;;
     WHILE not (Z = 0) DO
       Y ::= Y * Z;;
       Z ::= Z - 1
     END
   When this command terminates, the variable [Y] will contain the
   factorial of the initial value of [X].
*)

(** Here is the formal definition of the syntax of commands: *)

Inductive com : Type :=
  | CSkip : com
  | CAss : id -> aexp -> com
  | CSeq : com -> com -> com
  | CIf : bexp -> com -> com -> com
  | CWhile : bexp -> com -> com.

Tactic Notation "com_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "SKIP" | Case_aux c "::=" | Case_aux c ";;"
  | Case_aux c "IFB" | Case_aux c "WHILE" ].

(** As usual, we can use a few [Notation] declarations to make things
    more readable.  We need to be a bit careful to avoid conflicts
    with Coq's built-in notations, so we'll keep this light -- in
    particular, we won't introduce any notations for [aexps] and
    [bexps] to avoid confusion with the numerical and boolean
    operators we've already defined.  We use the keyword [IFB] for
    conditionals instead of [IF], for similar reasons. *)

Notation "'SKIP'" :=
  CSkip.
Notation "x '::=' a" :=
  (CAss x a) (at level 60).
Notation "c1 ;; c2" :=
  (CSeq c1 c2) (at level 80, right associativity).
Notation "'WHILE' b 'DO' c 'END'" :=
  (CWhile b c) (at level 80, right associativity).
Notation "'IFB' c1 'THEN' c2 'ELSE' c3 'FI'" :=
  (CIf c1 c2 c3) (at level 80, right associativity).

(** For example, here is the factorial function again, written as a
    formal definition to Coq: *)

Definition fact_in_coq : com :=
  Z ::= AId X;;
  Y ::= ANum 1;;
  WHILE BNot (BEq (AId Z) (ANum 0)) DO
    Y ::= AMult (AId Y) (AId Z);;
    Z ::= AMinus (AId Z) (ANum 1)
  END.

(* ########################### <a name="lab428"></a><h2 class="section">Examples</h2>

<div class="paragraph"> </div>

 Assignment: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="plus2"><span class="id" type="definition">plus2</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 2)<a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="XtimesYinZ"><span class="id" type="definition">XtimesYinZ</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#AMult"><span class="id" type="constructor">AMult</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>)<a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="subtract_slowly_body"><span class="id" type="definition">subtract_slowly_body</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1) <a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1).<br/>

<br/>
</div>

<div class="doc">
<a name="lab429"></a><h3 class="section">Loops</h3>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="subtract_slowly"><span class="id" type="definition">subtract_slowly</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0)) <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#subtract_slowly_body"><span class="id" type="definition">subtract_slowly_body</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="subtract_3_from_5_slowly"><span class="id" type="definition">subtract_3_from_5_slowly</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 3 <a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 5 <a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#subtract_slowly"><span class="id" type="definition">subtract_slowly</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab430"></a><h3 class="section">An infinite loop:</h3>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="loop"><span class="id" type="definition">loop</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab431"></a><h1 class="section">Evaluation</h1>

<div class="paragraph"> </div>

 Next we need to define what it means to evaluate an Imp command.
    The fact that <span class="inlinecode"><span class="id" type="var">WHILE</span></span> loops don't necessarily terminate makes defining
    an evaluation function tricky... 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab432"></a><h2 class="section">Evaluation as a Function (Failed Attempt)</h2>

<div class="paragraph"> </div>

 Here's an attempt at defining an evaluation function for commands,
    omitting the <span class="inlinecode"><span class="id" type="var">WHILE</span></span> case. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="ceval_fun_no_while"><span class="id" type="definition">ceval_fun_no_while</span></a> (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">c</span> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a>) : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Imp.html#c"><span class="id" type="variable">c</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">x</span> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <span class="id" type="var">a1</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">x</span> (<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">a1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">c1</span> <a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <span class="id" type="var">c2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">st'</span> := <a class="idref" href="Imp.html#ceval_fun_no_while"><span class="id" type="definition">ceval_fun_no_while</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">c1</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#ceval_fun_no_while"><span class="id" type="definition">ceval_fun_no_while</span></a> <a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a> <span class="id" type="var">c2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <span class="id" type="var">b</span> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <span class="id" type="var">c1</span> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <span class="id" type="var">c2</span> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> (<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">b</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">then</span> <a class="idref" href="Imp.html#ceval_fun_no_while"><span class="id" type="definition">ceval_fun_no_while</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">c1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <a class="idref" href="Imp.html#ceval_fun_no_while"><span class="id" type="definition">ceval_fun_no_while</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <span class="id" type="var">c2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <span class="id" type="var">b</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <span class="id" type="var">c</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a>  <br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
In a traditional functional programming language like ML or
    Haskell we could write the <span class="inlinecode"><span class="id" type="var">WHILE</span></span> case as follows:
<pre>
  Fixpoint ceval_fun (st : state) (c : com) : state :=
    match c with
      ...
      | WHILE b DO c END =&gt;
          if (beval st b1)
            then ceval_fun st (c1; WHILE b DO c END)
            else st
    end.
</pre>
    Coq doesn't accept such a definition ("Error: Cannot guess
    decreasing argument of fix") because the function we want to
    define is not guaranteed to terminate. Indeed, it doesn't always
    terminate: for example, the full version of the <span class="inlinecode"><span class="id" type="var">ceval_fun</span></span>
    function applied to the <span class="inlinecode"><a class="idref" href="PE.html#loop"><span class="id" type="constructor">loop</span></a></span> program above would never
    terminate. Since Coq is not just a functional programming
    language, but also a consistent logic, any potentially
    non-terminating function needs to be rejected. Here is
    an (invalid!) Coq program showing what would go wrong if Coq
    allowed non-terminating recursive functions:
<pre>
     Fixpoint loop_false (n : nat) : False := loop_false n.
</pre>
    That is, propositions like <span class="inlinecode"><a class="idref" href="Logic.html#False"><span class="id" type="inductive">False</span></a></span> would become provable
    (e.g. <span class="inlinecode"><span class="id" type="var">loop_false</span></span> <span class="inlinecode">0</span> would be a proof of <span class="inlinecode"><a class="idref" href="Logic.html#False"><span class="id" type="inductive">False</span></a></span>), which
    would be a disaster for Coq's logical consistency.

<div class="paragraph"> </div>

    Thus, because it doesn't terminate on all inputs, the full version
    of <span class="inlinecode"><span class="id" type="var">ceval_fun</span></span> cannot be written in Coq -- at least not without
    additional tricks (see chapter <span class="inlinecode"><span class="id" type="library">ImpCEvalFun</span></span> if curious). 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab433"></a><h2 class="section">Evaluation as a Relation</h2>
 <a name="evaluationrelation-2"/> *)

(** Here's a better way: we define [ceval] as a _relation_ rather than
    a _function_ -- i.e., we define it in [Prop] instead of [Type], as
    we did for [aevalR] above. *)

(** This is an important change.  Besides freeing us from the awkward
    workarounds that would be needed to define evaluation as a
    function, it gives us a lot more flexibility in the definition.
    For example, if we added concurrency features to the language,
    we'd want the definition of evaluation to be non-deterministic --
    i.e., not only would it not be total, it would not even be a
    partial function! *)
(** We'll use the notation [c / st || st'] for our [ceval] relation:
    [c / st || st'] means that executing program [c] in a starting
    state [st] results in an ending state [st'].  This can be
    pronounced "[c] takes state [st] to [st']".

*)
(** *** Operational Semantics 
                           ----------------                            (E_Skip)
                           SKIP / st || st

                           aeval st a1 = n
                   --------------------------------                     (E_Ass)
                   x := a1 / st || (update st x n)

                           c1 / st || st'
                          c2 / st' || st''
                         -------------------                            (E_Seq)
                         c1;;c2 / st || st''

                          beval st b1 = true
                           c1 / st || st'
                -------------------------------------                (E_IfTrue)
                IF b1 THEN c1 ELSE c2 FI / st || st'

                         beval st b1 = false
                           c2 / st || st'
                -------------------------------------               (E_IfFalse)
                IF b1 THEN c1 ELSE c2 FI / st || st'

                         beval st b1 = false
                    ------------------------------                 (E_WhileEnd)
                    WHILE b DO c END / st || st

                          beval st b1 = true
                           c / st || st'
                  WHILE b DO c END / st' || st''
                  ---------------------------------               (E_WhileLoop)
                    WHILE b DO c END / st || st''
*)

(** Here is the formal definition.  (Make sure you understand
    how it corresponds to the inference rules.) *)

Reserved Notation "c1 '/' st '||' st'" (at level 40, st at level 39).

Inductive ceval : com -> state -> state -> Prop :=
  | E_Skip : forall st,
      SKIP / st || st
  | E_Ass  : forall st a1 n x,
      aeval st a1 = n ->
      (x ::= a1) / st || (update st x n)
  | E_Seq : forall c1 c2 st st' st'',
      c1 / st  || st' ->
      c2 / st' || st'' ->
      (c1 ;; c2) / st || st''
  | E_IfTrue : forall st st' b c1 c2,
      beval st b = true ->
      c1 / st || st' ->
      (IFB b THEN c1 ELSE c2 FI) / st || st'
  | E_IfFalse : forall st st' b c1 c2,
      beval st b = false ->
      c2 / st || st' ->
      (IFB b THEN c1 ELSE c2 FI) / st || st'
  | E_WhileEnd : forall b st c,
      beval st b = false ->
      (WHILE b DO c END) / st || st
  | E_WhileLoop : forall st st' st'' b c,
      beval st b = true ->
      c / st || st' ->
      (WHILE b DO c END) / st' || st'' ->
      (WHILE b DO c END) / st || st''

  where "c1 '/' st '||' st'" := (ceval c1 st st').

Tactic Notation "ceval_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "E_Skip" | Case_aux c "E_Ass" | Case_aux c "E_Seq"
  | Case_aux c "E_IfTrue" | Case_aux c "E_IfFalse"
  | Case_aux c "E_WhileEnd" | Case_aux c "E_WhileLoop" ].

(** *** *)
(** The cost of defining evaluation as a relation instead of a
    function is that we now need to construct _proofs_ that some
    program evaluates to some result state, rather than just letting
    Coq's computation mechanism do it for us. *)

Example ceval_example1:
    (X ::= ANum 2;;
     IFB BLe (AId X) (ANum 1)
       THEN Y ::= ANum 3
       ELSE Z ::= ANum 4
     FI)
   / empty_state
   || (update (update empty_state X 2) Z 4).
Proof.
  (* We must supply the intermediate state *)
  apply E_Seq with (update empty_state X 2).
  Case "assignment command".
    apply E_Ass. reflexivity.
  Case "if command".
    apply E_IfFalse.
      reflexivity.
      apply E_Ass. reflexivity.  Qed.

(** **** Exercise: 2 stars (ceval_example2) *)
Example ceval_example2:
    (X ::= ANum 0;; Y ::= ANum 1;; Z ::= ANum 2) / empty_state ||
    (update (update (update empty_state X 0) Y 1) Z 2).
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 3 stars, advanced (pup_to_n) *)
(** Write an Imp program that sums the numbers from [1] to
   [X] (inclusive: [1 + 2 + ... + X]) in the variable [Y].
   Prove that this program executes as intended for X = 2
   (this latter part is trickier than you might expect). *)

Definition pup_to_n : com :=
  (* FILL IN HERE *) admit.

Theorem pup_to_2_ceval :
  pup_to_n / (update empty_state X 2) ||
    update (update (update (update (update (update empty_state
      X 2) Y 0) Y 2) X 1) Y 3) X 0.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)


(* ########################### <a name="lab434"></a><h2 class="section">Determinism of Evaluation</h2>
 <a name="determinism"/> *)

(** Changing from a computational to a relational definition of
    evaluation is a good move because it allows us to escape from the
    artificial requirement (imposed by Coq's restrictions on
    [Fixpoint] definitions) that evaluation should be a total
    function.  But it also raises a question: Is the second definition
    of evaluation actually a partial function?  That is, is it
    possible that, beginning from the same state [st], we could
    evaluate some command [c] in different ways to reach two different
    output states [st'] and [st'']?

    In fact, this cannot happen: [ceval] is a partial function.
    Here's the proof: *)

Theorem ceval_deterministic: forall c st st1 st2,
     c / st || st1  ->
     c / st || st2 ->
     st1 = st2.
Proof.
  intros c st st1 st2 E1 E2.
  generalize dependent st2.
  ceval_cases (induction E1) Case;
           intros st2 E2; inversion E2; subst.
  Case "E_Skip". reflexivity.
  Case "E_Ass". reflexivity.
  Case "E_Seq".
    assert (st' = st'0) as EQ1.
      SCase "Proof of assertion". apply IHE1_1; assumption.
    subst st'0.
    apply IHE1_2. assumption.
  Case "E_IfTrue".
    SCase "b1 evaluates to true".
      apply IHE1. assumption.
    SCase "b1 evaluates to false (contradiction)".
      rewrite H in H5. inversion H5.
  Case "E_IfFalse".
    SCase "b1 evaluates to true (contradiction)".
      rewrite H in H5. inversion H5.
    SCase "b1 evaluates to false".
      apply IHE1. assumption.
  Case "E_WhileEnd".
    SCase "b1 evaluates to false".
      reflexivity.
    SCase "b1 evaluates to true (contradiction)".
      rewrite H in H2. inversion H2.
  Case "E_WhileLoop".
    SCase "b1 evaluates to false (contradiction)".
      rewrite H in H4. inversion H4.
    SCase "b1 evaluates to true".
      assert (st' = st'0) as EQ1.
        SSCase "Proof of assertion". apply IHE1_1; assumption.
      subst st'0.
      apply IHE1_2. assumption.  Qed.

(* ########################### <a name="lab435"></a><h1 class="section">Reasoning About Imp Programs</h1>

<div class="paragraph"> </div>

 We'll get much deeper into systematic techniques for reasoning
    about Imp programs in the following chapters, but we can do quite
    a bit just working with the bare definitions. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="plus2_spec"><span class="id" type="lemma">plus2_spec</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> <span class="id" type="var">n</span> <span class="id" type="var">st'</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#plus2"><span class="id" type="definition">plus2</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> 2.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> <span class="id" type="var">n</span> <span class="id" type="var">st'</span> <span class="id" type="var">HX</span> <span class="id" type="var">Heval</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">Heval</span>. <span class="id" type="tactic">subst</span>. <span class="id" type="tactic">clear</span> <span class="id" type="var">Heval</span>. <span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#update_eq"><span class="id" type="axiom">update_eq</span></a>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab436"></a><h4 class="section">Exercise: 3 stars (XtimesYinZ_spec)</h4>
 State and prove a specification of <span class="inlinecode"><a class="idref" href="Imp.html#XtimesYinZ"><span class="id" type="definition">XtimesYinZ</span></a></span>. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab437"></a><h4 class="section">Exercise: 3 stars (loop_never_stops)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="loop_never_stops"><span class="id" type="lemma">loop_never_stops</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~(</span></a><a class="idref" href="Imp.html#loop"><span class="id" type="definition">loop</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">contra</span>. <span class="id" type="tactic">unfold</span> <a class="idref" href="Imp.html#loop"><span class="id" type="definition">loop</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">contra</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>) <span class="id" type="keyword">as</span> <span class="id" type="var">loopdef</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Heqloopdef</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab438"></a><h4 class="section">Exercise: 3 stars (no_whilesR)</h4>
 Consider the definition of the <span class="inlinecode"><a class="idref" href="Imp.html#no_whiles"><span class="id" type="definition">no_whiles</span></a></span> property below: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="no_whiles"><span class="id" type="definition">no_whiles</span></a> (<span class="id" type="var">c</span> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Imp.html#c"><span class="id" type="variable">c</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a>       ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a><br/>
&nbsp;&nbsp;| <span class="id" type="var">_</span> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <span class="id" type="var">_</span>    ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a><br/>
&nbsp;&nbsp;| <span class="id" type="var">c1</span> <a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <span class="id" type="var">c2</span>  ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#andb"><span class="id" type="definition">andb</span></a> (<a class="idref" href="Imp.html#no_whiles"><span class="id" type="definition">no_whiles</span></a> <span class="id" type="var">c1</span>) (<a class="idref" href="Imp.html#no_whiles"><span class="id" type="definition">no_whiles</span></a> <span class="id" type="var">c2</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <span class="id" type="var">_</span> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <span class="id" type="var">ct</span> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <span class="id" type="var">cf</span> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#andb"><span class="id" type="definition">andb</span></a> (<a class="idref" href="Imp.html#no_whiles"><span class="id" type="definition">no_whiles</span></a> <span class="id" type="var">ct</span>) (<a class="idref" href="Imp.html#no_whiles"><span class="id" type="definition">no_whiles</span></a> <span class="id" type="var">cf</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <span class="id" type="var">_</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <span class="id" type="var">_</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>  ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
This property yields <span class="inlinecode"><a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a></span> just on programs that
    have no while loops.  Using <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>, write a property
    <span class="inlinecode"><a class="idref" href="Imp.html#no_whilesR"><span class="id" type="inductive">no_whilesR</span></a></span> such that <span class="inlinecode"><a class="idref" href="Imp.html#no_whilesR"><span class="id" type="inductive">no_whilesR</span></a></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> is provable exactly when <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span>
    is a program with no while loops.  Then prove its equivalence
    with <span class="inlinecode"><a class="idref" href="Imp.html#no_whiles"><span class="id" type="definition">no_whiles</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="no_whilesR"><span class="id" type="inductive">no_whilesR</span></a>: <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;<br/>
&nbsp;&nbsp;.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="no_whiles_eqv"><span class="id" type="lemma">no_whiles_eqv</span></a>:<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">∀</span> <span class="id" type="var">c</span>, <a class="idref" href="Imp.html#no_whiles"><span class="id" type="definition">no_whiles</span></a> <a class="idref" href="Imp.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="Imp.html#no_whilesR"><span class="id" type="inductive">no_whilesR</span></a> <a class="idref" href="Imp.html#c"><span class="id" type="variable">c</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab439"></a><h4 class="section">Exercise: 4 stars (no_whiles_terminating)</h4>
 Imp programs that don't involve while loops always terminate.
    State and prove a theorem that says this.  (Use either <span class="inlinecode"><a class="idref" href="Imp.html#no_whiles"><span class="id" type="definition">no_whiles</span></a></span> or <span class="inlinecode"><a class="idref" href="Imp.html#no_whilesR"><span class="id" type="inductive">no_whilesR</span></a></span>, as you prefer.) 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab440"></a><h1 class="section">Additional Exercises</h1>

<div class="paragraph"> </div>

<a name="lab441"></a><h4 class="section">Exercise: 3 stars (stack_compiler)</h4>
 HP Calculators, programming languages like Forth and Postscript,
    and abstract machines like the Java Virtual Machine all evaluate
    arithmetic expressions using a stack. For instance, the expression
<pre>
   (2*3)+(3*(4-2))
</pre>
   would be entered as
<pre>
   2 3 * 3 4 2 - * +
</pre>
   and evaluated like this:
<pre>
  []            |    2 3 * 3 4 2 - * +
  [2]           |    3 * 3 4 2 - * +
  [3, 2]        |    * 3 4 2 - * +
  [6]           |    3 4 2 - * +
  [3, 6]        |    4 2 - * +
  [4, 3, 6]     |    2 - * +
  [2, 4, 3, 6]  |    - * +
  [2, 3, 6]     |    * +
  [6, 6]        |    +
  [12]          |
</pre>

<div class="paragraph"> </div>

  The task of this exercise is to write a small compiler that
  translates <span class="inlinecode"><a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a></span>s into stack machine instructions.

<div class="paragraph"> </div>

  The instruction set for our stack language will consist of the
  following instructions:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><a class="idref" href="Imp.html#SPush"><span class="id" type="constructor">SPush</span></a></span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span>: Push the number <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> on the stack.

</li>
<li> <span class="inlinecode"><a class="idref" href="Imp.html#SLoad"><span class="id" type="constructor">SLoad</span></a></span> <span class="inlinecode"><a class="idref" href="RecordSub.html#Examples.x"><span class="id" type="abbreviation">x</span></a></span>: Load the identifier <span class="inlinecode"><a class="idref" href="RecordSub.html#Examples.x"><span class="id" type="abbreviation">x</span></a></span> from the store and push it
                  on the stack

</li>
<li> <span class="inlinecode"><a class="idref" href="Imp.html#SPlus"><span class="id" type="constructor">SPlus</span></a></span>:   Pop the two top numbers from the stack, add them, and
                  push the result onto the stack.

</li>
<li> <span class="inlinecode"><a class="idref" href="Imp.html#SMinus"><span class="id" type="constructor">SMinus</span></a></span>:  Similar, but subtract.

</li>
<li> <span class="inlinecode"><a class="idref" href="Imp.html#SMult"><span class="id" type="constructor">SMult</span></a></span>:   Similar, but multiply. 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="sinstr"><span class="id" type="inductive">sinstr</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
| <a name="SPush"><span class="id" type="constructor">SPush</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="Imp.html#sinstr"><span class="id" type="inductive">sinstr</span></a><br/>
| <a name="SLoad"><span class="id" type="constructor">SLoad</span></a> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a> → <a class="idref" href="Imp.html#sinstr"><span class="id" type="inductive">sinstr</span></a><br/>
| <a name="SPlus"><span class="id" type="constructor">SPlus</span></a> : <a class="idref" href="Imp.html#sinstr"><span class="id" type="inductive">sinstr</span></a><br/>
| <a name="SMinus"><span class="id" type="constructor">SMinus</span></a> : <a class="idref" href="Imp.html#sinstr"><span class="id" type="inductive">sinstr</span></a><br/>
| <a name="SMult"><span class="id" type="constructor">SMult</span></a> : <a class="idref" href="Imp.html#sinstr"><span class="id" type="inductive">sinstr</span></a>.<br/>

<br/>
</div>

<div class="doc">
Write a function to evaluate programs in the stack language. It
    takes as input a state, a stack represented as a list of
    numbers (top stack item is the head of the list), and a program
    represented as a list of instructions, and returns the stack after
    executing the program. Test your function on the examples below.

<div class="paragraph"> </div>

    Note that the specification leaves unspecified what to do when
    encountering an <span class="inlinecode"><a class="idref" href="Imp.html#SPlus"><span class="id" type="constructor">SPlus</span></a></span>, <span class="inlinecode"><a class="idref" href="Imp.html#SMinus"><span class="id" type="constructor">SMinus</span></a></span>, or <span class="inlinecode"><a class="idref" href="Imp.html#SMult"><span class="id" type="constructor">SMult</span></a></span> instruction if the
    stack contains less than two elements.  In a sense, it is
    immaterial what we do, since our compiler will never emit such a
    malformed program. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="s_execute"><span class="id" type="definition">s_execute</span></a> (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">stack</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">prog</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Imp.html#sinstr"><span class="id" type="inductive">sinstr</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br/>
 <a class="idref" href="SfLib.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="s_execute1"><span class="id" type="definition">s_execute1</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#s_execute"><span class="id" type="definition">s_execute</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="Imp.html#SPush"><span class="id" type="constructor">SPush</span></a> 5<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">;</span></a> <a class="idref" href="Imp.html#SPush"><span class="id" type="constructor">SPush</span></a> 3<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">;</span></a> <a class="idref" href="Imp.html#SPush"><span class="id" type="constructor">SPush</span></a> 1<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">;</span></a> <a class="idref" href="Imp.html#SMinus"><span class="id" type="constructor">SMinus</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a><br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a>2<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">;</span></a> 5<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="s_execute2"><span class="id" type="definition">s_execute2</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#s_execute"><span class="id" type="definition">s_execute</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> 3) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a>3<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">;</span></a>4<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="Imp.html#SPush"><span class="id" type="constructor">SPush</span></a> 4<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">;</span></a> <a class="idref" href="Imp.html#SLoad"><span class="id" type="constructor">SLoad</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">;</span></a> <a class="idref" href="Imp.html#SMult"><span class="id" type="constructor">SMult</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">;</span></a> <a class="idref" href="Imp.html#SPlus"><span class="id" type="constructor">SPlus</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a><br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a>15<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">;</span></a> 4<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Next, write a function which compiles an <span class="inlinecode"><a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a></span> into a stack
    machine program. The effect of running the program should be the
    same as pushing the value of the expression on the stack. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="s_compile"><span class="id" type="definition">s_compile</span></a> (<span class="id" type="var">e</span> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Imp.html#sinstr"><span class="id" type="inductive">sinstr</span></a> :=<br/>
 <a class="idref" href="SfLib.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
</div>

<div class="doc">
After you've defined <span class="inlinecode"><a class="idref" href="Imp.html#s_compile"><span class="id" type="definition">s_compile</span></a></span>, uncomment the following to test
    that it works. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab442"></a><h4 class="section">Exercise: 3 stars, advanced (stack_compiler_correct)</h4>
 The task of this exercise is to prove the correctness of the
    calculator implemented in the previous exercise.  Remember that
    the specification left unspecified what to do when encountering an
    <span class="inlinecode"><a class="idref" href="Imp.html#SPlus"><span class="id" type="constructor">SPlus</span></a></span>, <span class="inlinecode"><a class="idref" href="Imp.html#SMinus"><span class="id" type="constructor">SMinus</span></a></span>, or <span class="inlinecode"><a class="idref" href="Imp.html#SMult"><span class="id" type="constructor">SMult</span></a></span> instruction if the stack contains
    less than two elements.  (In order to make your correctness proof
    easier you may find it useful to go back and change your
    implementation!)

<div class="paragraph"> </div>

    Prove the following theorem, stating that the <span class="inlinecode"><span class="id" type="var">compile</span></span> function
    behaves correctly.  You will need to start by stating a more
    general lemma to get a usable induction hypothesis; the main
    theorem will then be a simple corollary of this lemma. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="s_compile_correct"><span class="id" type="lemma">s_compile_correct</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">e</span> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#s_execute"><span class="id" type="definition">s_execute</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a> (<a class="idref" href="Imp.html#s_compile"><span class="id" type="definition">s_compile</span></a> <a class="idref" href="Imp.html#e"><span class="id" type="variable">e</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a> <a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab443"></a><h4 class="section">Exercise: 5 stars, advanced (break_imp)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Module</span> <a name="BreakImp"><span class="id" type="module">BreakImp</span></a>.<br/>

<br/>
</div>

<div class="doc">
Imperative languages such as C or Java often have a <span class="inlinecode"><span class="id" type="var">break</span></span> or
    similar statement for interrupting the execution of loops. In this
    exercise we will consider how to add <span class="inlinecode"><span class="id" type="var">break</span></span> to Imp.

<div class="paragraph"> </div>

    First, we need to enrich the language of commands with an
    additional case. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="BreakImp.com"><span class="id" type="inductive">com</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="BreakImp.CSkip"><span class="id" type="constructor">CSkip</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="BreakImp.CBreak"><span class="id" type="constructor">CBreak</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="BreakImp.CAss"><span class="id" type="constructor">CAss</span></a> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a> → <a class="idref" href="Imp.html#BreakImp.aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="BreakImp.CSeq"><span class="id" type="constructor">CSeq</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="BreakImp.CIf"><span class="id" type="constructor">CIf</span></a> : <a class="idref" href="Imp.html#BreakImp.bexp"><span class="id" type="inductive">bexp</span></a> → <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="BreakImp.CWhile"><span class="id" type="constructor">CWhile</span></a> : <a class="idref" href="Imp.html#BreakImp.bexp"><span class="id" type="inductive">bexp</span></a> → <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "com_cases" <span class="id" type="var">tactic</span>(<span class="id" type="tactic">first</span>) <span class="id" type="var">ident</span>(<span class="id" type="var">c</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span>;<br/>
&nbsp;&nbsp;[ <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "SKIP" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "BREAK" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "::=" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> ";"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "IFB" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "WHILE" ].<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name="BreakImp.::'SKIP'"><span class="id" type="notation">"</span></a>'SKIP'" :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#BreakImp.CSkip"><span class="id" type="constructor">CSkip</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="BreakImp.::'BREAK'"><span class="id" type="notation">"</span></a>'BREAK'" :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#BreakImp.CBreak"><span class="id" type="constructor">CBreak</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="BreakImp.::x_'::='_x"><span class="id" type="notation">"</span></a>x '::=' a" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Imp.html#BreakImp.CAss"><span class="id" type="constructor">CAss</span></a> <span class="id" type="var">x</span> <span class="id" type="var">a</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 60).<br/>
<span class="id" type="keyword">Notation</span> <a name="BreakImp.::x_';'_x"><span class="id" type="notation">"</span></a>c1 ; c2" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Imp.html#BreakImp.CSeq"><span class="id" type="constructor">CSeq</span></a> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="BreakImp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">"</span></a>'WHILE' b 'DO' c 'END'" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Imp.html#BreakImp.CWhile"><span class="id" type="constructor">CWhile</span></a> <span class="id" type="var">b</span> <span class="id" type="var">c</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="BreakImp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">"</span></a>'IFB' c1 'THEN' c2 'ELSE' c3 'FI'" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Imp.html#BreakImp.CIf"><span class="id" type="constructor">CIf</span></a> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span> <span class="id" type="var">c3</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>

<br/>
</div>

<div class="doc">
Next, we need to define the behavior of <span class="inlinecode"><span class="id" type="var">BREAK</span></span>.  Informally,
    whenever <span class="inlinecode"><span class="id" type="var">BREAK</span></span> is executed in a sequence of commands, it stops
    the execution of that sequence and signals that the innermost
    enclosing loop (if any) should terminate. If there aren't any
    enclosing loops, then the whole program simply terminates. The
    final state should be the same as the one in which the <span class="inlinecode"><span class="id" type="var">BREAK</span></span>
    statement was executed.

<div class="paragraph"> </div>

    One important point is what to do when there are multiple loops
    enclosing a given <span class="inlinecode"><span class="id" type="var">BREAK</span></span>. In those cases, <span class="inlinecode"><span class="id" type="var">BREAK</span></span> should only
    terminate the <i>innermost</i> loop where it occurs. Thus, after
    executing the following piece of code...
   X ::= 0;
   Y ::= 1;
   WHILE 0 &lt;&gt; Y DO
     WHILE TRUE DO
       BREAK
     END;
     X ::= 1;
     Y ::= Y - 1
   END
    ... the value of <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> should be <span class="inlinecode">1</span>, and not <span class="inlinecode">0</span>.

<div class="paragraph"> </div>

    One way of expressing this behavior is to add another parameter to
    the evaluation relation that specifies whether evaluation of a
    command executes a <span class="inlinecode"><span class="id" type="var">BREAK</span></span> statement: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="BreakImp.status"><span class="id" type="inductive">status</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="BreakImp.SContinue"><span class="id" type="constructor">SContinue</span></a> : <a class="idref" href="Imp.html#status"><span class="id" type="inductive">status</span></a><br/>
&nbsp;&nbsp;| <a name="BreakImp.SBreak"><span class="id" type="constructor">SBreak</span></a> : <a class="idref" href="Imp.html#status"><span class="id" type="inductive">status</span></a>.<br/>

<br/>
<span class="id" type="keyword">Reserved Notation</span> "c1 '/' st '||' s '/' st'"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 40, <span class="id" type="var">st</span>, <span class="id" type="var">s</span> <span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 39).<br/>

<br/>
</div>

<div class="doc">
Intuitively, <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="References.html#STLCRef.ExampleVariables.s"><span class="id" type="definition">s</span></a></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span> means that, if <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> is started in
    state <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span>, then it terminates in state <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span> and either signals
    that any surrounding loop (or the whole program) should exit
    immediately (<span class="inlinecode"><a class="idref" href="References.html#STLCRef.ExampleVariables.s"><span class="id" type="definition">s</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Imp.html#BreakImp.SBreak"><span class="id" type="constructor">SBreak</span></a></span>) or that execution should continue
    normally (<span class="inlinecode"><a class="idref" href="References.html#STLCRef.ExampleVariables.s"><span class="id" type="definition">s</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Imp.html#BreakImp.SContinue"><span class="id" type="constructor">SContinue</span></a></span>).

<div class="paragraph"> </div>

    The definition of the "<span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="References.html#STLCRef.ExampleVariables.s"><span class="id" type="definition">s</span></a></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>" relation is very
    similar to the one we gave above for the regular evaluation
    relation (<span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="References.html#STLCRef.ExampleVariables.s"><span class="id" type="definition">s</span></a></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>) -- we just need to handle the
    termination signals appropriately:

<div class="paragraph"> </div>

<ul class="doclist">
<li> If the command is <span class="inlinecode"><span class="id" type="var">SKIP</span></span>, then the state doesn't change, and
      execution of any enclosing loop can continue normally.

<div class="paragraph"> </div>


</li>
<li> If the command is <span class="inlinecode"><span class="id" type="var">BREAK</span></span>, the state stays unchanged, but we
      signal a <span class="inlinecode"><a class="idref" href="Imp.html#BreakImp.SBreak"><span class="id" type="constructor">SBreak</span></a></span>.

<div class="paragraph"> </div>


</li>
<li> If the command is an assignment, then we update the binding for
      that variable in the state accordingly and signal that execution
      can continue normally.

<div class="paragraph"> </div>


</li>
<li> If the command is of the form <span class="inlinecode"><span class="id" type="var">IF</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">THEN</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode"><span class="id" type="var">ELSE</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> <span class="inlinecode"><span class="id" type="var">FI</span></span>, then
      the state is updated as in the original semantics of Imp, except
      that we also propagate the signal from the execution of
      whichever branch was taken.

<div class="paragraph"> </div>


</li>
<li> If the command is a sequence <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode">;</span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span>, we first execute
      <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span>. If this yields a <span class="inlinecode"><a class="idref" href="Imp.html#BreakImp.SBreak"><span class="id" type="constructor">SBreak</span></a></span>, we skip the execution of <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span>
      and propagate the <span class="inlinecode"><a class="idref" href="Imp.html#BreakImp.SBreak"><span class="id" type="constructor">SBreak</span></a></span> signal to the surrounding context;
      the resulting state should be the same as the one obtained by
      executing <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> alone. Otherwise, we execute <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> on the state
      obtained after executing <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span>, and propagate the signal that was
      generated there.

<div class="paragraph"> </div>


</li>
<li> Finally, for a loop of the form <span class="inlinecode"><span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span></span>, the
      semantics is almost the same as before. The only difference is
      that, when <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> evaluates to true, we execute <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> and check the
      signal that it raises. If that signal is <span class="inlinecode"><a class="idref" href="Imp.html#BreakImp.SContinue"><span class="id" type="constructor">SContinue</span></a></span>, then the
      execution proceeds as in the original semantics. Otherwise, we
      stop the execution of the loop, and the resulting state is the
      same as the one resulting from the execution of the current
      iteration. In either case, since <span class="inlinecode"><span class="id" type="var">BREAK</span></span> only terminates the
      innermost loop, <span class="inlinecode"><span class="id" type="var">WHILE</span></span> signals <span class="inlinecode"><a class="idref" href="Imp.html#BreakImp.SContinue"><span class="id" type="constructor">SContinue</span></a></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 Based on the above description, complete the definition of the
    <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.ceval"><span class="id" type="inductive">ceval</span></a></span> relation. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="BreakImp.ceval"><span class="id" type="inductive">ceval</span></a> : <a class="idref" href="Imp.html#BreakImp.com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Imp.html#BreakImp.state"><span class="id" type="definition">state</span></a> → <a class="idref" href="Imp.html#BreakImp.status"><span class="id" type="inductive">status</span></a> → <a class="idref" href="Imp.html#BreakImp.state"><span class="id" type="definition">state</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="BreakImp.E_Skip"><span class="id" type="constructor">E_Skip</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">st</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#BreakImp.CSkip"><span class="id" type="constructor">CSkip</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#BreakImp.SContinue"><span class="id" type="constructor">SContinue</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a><br/>
&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;<span class="id" type="keyword">where</span> <a name="BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">"</span></a>c1 '/' st '||' s '/' st'" := (<a class="idref" href="Imp.html#ceval"><span class="id" type="inductive">ceval</span></a> <span class="id" type="var">c1</span> <span class="id" type="var">st</span> <span class="id" type="var">s</span> <span class="id" type="var">st'</span>).<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "ceval_cases" <span class="id" type="var">tactic</span>(<span class="id" type="tactic">first</span>) <span class="id" type="var">ident</span>(<span class="id" type="var">c</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span>;<br/>
&nbsp;&nbsp;[ <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_Skip"<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;].<br/>

<br/>
</div>

<div class="doc">
Now the following properties of your definition of <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.ceval"><span class="id" type="inductive">ceval</span></a></span>: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="BreakImp.break_ignore"><span class="id" type="lemma">break_ignore</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">c</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BreakImp.::'BREAK'"><span class="id" type="notation">BREAK</span></a><a class="idref" href="Imp.html#BreakImp.::x_';'_x"><span class="id" type="notation">;</span></a> <a class="idref" href="Imp.html#c"><span class="id" type="variable">c</span></a><a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#s"><span class="id" type="variable">s</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="BreakImp.while_continue"><span class="id" type="lemma">while_continue</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">s</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BreakImp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#BreakImp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Imp.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#BreakImp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#s"><span class="id" type="variable">s</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#s"><span class="id" type="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#BreakImp.SContinue"><span class="id" type="constructor">SContinue</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="BreakImp.while_stops_on_break"><span class="id" type="lemma">while_stops_on_break</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#BreakImp.beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#BreakImp.SBreak"><span class="id" type="constructor">SBreak</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BreakImp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#BreakImp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Imp.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#BreakImp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#BreakImp.SContinue"><span class="id" type="constructor">SContinue</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab444"></a><h4 class="section">Exercise: 3 stars, advanced, optional (while_break_true)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="BreakImp.while_break_true"><span class="id" type="lemma">while_break_true</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BreakImp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#BreakImp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Imp.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#BreakImp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#BreakImp.SContinue"><span class="id" type="constructor">SContinue</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#BreakImp.beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a> <a class="idref" href="Imp.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <span class="id" type="var">st''</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="Imp.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st''"><span class="id" type="variable">st''</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#BreakImp.SBreak"><span class="id" type="constructor">SBreak</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab445"></a><h4 class="section">Exercise: 4 stars, advanced, optional (ceval_deterministic)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="BreakImp.ceval_deterministic"><span class="id" type="lemma">ceval_deterministic</span></a>: <span class="id" type="keyword">∀</span> (<span class="id" type="var">c</span>:<a class="idref" href="Imp.html#BreakImp.com"><span class="id" type="inductive">com</span></a>) <span class="id" type="var">st</span> <span class="id" type="var">st1</span> <span class="id" type="var">st2</span> <span class="id" type="var">s1</span> <span class="id" type="var">s2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#s1"><span class="id" type="variable">s1</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st1"><span class="id" type="variable">st1</span></a>  →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#s2"><span class="id" type="variable">s2</span></a> <a class="idref" href="Imp.html#BreakImp.::x_'/'_x_'||'_x_'/'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#st2"><span class="id" type="variable">st2</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#st1"><span class="id" type="variable">st1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#st2"><span class="id" type="variable">st2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Imp.html#s1"><span class="id" type="variable">s1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#s2"><span class="id" type="variable">s2</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Imp.html#BreakImp"><span class="id" type="module">BreakImp</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab446"></a><h4 class="section">Exercise: 3 stars, optional (short_circuit)</h4>
 Most modern programming languages use a "short-circuit" evaluation
    rule for boolean <span class="inlinecode"><a class="idref" href="Logic.html#and"><span class="id" type="inductive">and</span></a></span>: to evaluate <span class="inlinecode"><a class="idref" href="Imp.html#BAnd"><span class="id" type="constructor">BAnd</span></a></span> <span class="inlinecode"><a class="idref" href="Basics.html#b1"><span class="id" type="variable">b1</span></a></span> <span class="inlinecode"><a class="idref" href="Basics.html#b2"><span class="id" type="variable">b2</span></a></span>, first evaluate
    <span class="inlinecode"><a class="idref" href="Basics.html#b1"><span class="id" type="variable">b1</span></a></span>.  If it evaluates to <span class="inlinecode"><a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a></span>, then the entire <span class="inlinecode"><a class="idref" href="Imp.html#BAnd"><span class="id" type="constructor">BAnd</span></a></span>
    expression evaluates to <span class="inlinecode"><a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a></span> immediately, without evaluating
    <span class="inlinecode"><a class="idref" href="Basics.html#b2"><span class="id" type="variable">b2</span></a></span>.  Otherwise, <span class="inlinecode"><a class="idref" href="Basics.html#b2"><span class="id" type="variable">b2</span></a></span> is evaluated to determine the result of the
    <span class="inlinecode"><a class="idref" href="Imp.html#BAnd"><span class="id" type="constructor">BAnd</span></a></span> expression.

<div class="paragraph"> </div>

    Write an alternate version of <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span> that performs short-circuit
    evaluation of <span class="inlinecode"><a class="idref" href="Imp.html#BAnd"><span class="id" type="constructor">BAnd</span></a></span> in this manner, and prove that it is
    equivalent to <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span>. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab447"></a><h4 class="section">Exercise: 4 stars, optional (add_for_loop)</h4>
 Add C-style <span class="inlinecode"><span class="id" type="keyword">for</span></span> loops to the language of commands, update the
    <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.ceval"><span class="id" type="inductive">ceval</span></a></span> definition to define the semantics of <span class="inlinecode"><span class="id" type="keyword">for</span></span> loops, and add
    cases for <span class="inlinecode"><span class="id" type="keyword">for</span></span> loops as needed so that all the proofs in this file
    are accepted by Coq.

<div class="paragraph"> </div>

    A <span class="inlinecode"><span class="id" type="keyword">for</span></span> loop should be parameterized by (a) a statement executed
    initially, (b) a test that is run on each iteration of the loop to
    determine whether the loop should continue, (c) a statement
    executed at the end of each loop iteration, and (d) a statement
    that makes up the body of the loop.  (You don't need to worry
    about making up a concrete Notation for <span class="inlinecode"><span class="id" type="keyword">for</span></span> loops, but feel free
    to play with this too if you like.) 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>